
>>>>src/Compiler.elm
module Compiler exposing (..)

import Ast
import Ast.Statement exposing (Statement)
import List exposing (..)
import Helpers exposing (..)
import ExContext exposing (Context, Aliases)
import ExAlias
import ExStatement
import Dict
import Regex exposing (..)


version : String
version =
    "0.3.33"


glueStart : String
glueStart =
    (ind 0)
        ++ "use Elchemy"
        ++ "\n"


glueEnd : String
glueEnd =
    "\n"
        ++ String.trim
            """
         end
         """


getName : String -> ( String, String )
getName file =
    case String.split "\n" file of
        n :: rest ->
            ( n, String.join "\n" rest )

        [] ->
            ( "", "" )


tree : String -> String
tree m =
    case String.split ">>>>" m of
        [ single ] ->
            single
                |> parse "NoName.elm"
                |> getContext
                |> (\( c, a ) ->
                        case c of
                            Nothing ->
                                Debug.crash "Failed getting context"

                            Just c ->
                                getCode c a
                   )

        multiple ->
            let
                files =
                    multiple
                        |> map getName
                        |> map (\( name, code ) -> ( name, parse name code ))

                wContexts =
                    files
                        |> map (\( name, ast ) -> ( name, getContext ast ))
                        |> filterMap
                            (\a ->
                                case a of
                                    ( _, ( Nothing, _ ) ) ->
                                        Nothing

                                    ( name, ( Just c, ast ) ) ->
                                        Just ( name, c, ast )
                            )

                commonAliases =
                    wContexts
                        |> map (\( name, ctx, ast ) -> ctx.aliases)
                        |> getCommonAliases

                wTrueContexts =
                    wContexts
                        |> map (\( name, c, ast ) -> ( name, { c | aliases = commonAliases }, ast ))
            in
                wTrueContexts
                    |> map
                        (\( name, c, ast ) ->
                            ">>>>" ++ name ++ "\n" ++ getCode c ast
                        )
                    |> String.join "\n"


getCommonAliases : List Aliases -> Aliases
getCommonAliases a =
    foldl
        (\aliases acc ->
            Dict.merge
                Dict.insert
                typeAliasDuplicate
                Dict.insert
                acc
                aliases
                Dict.empty
        )
        (Dict.empty)
        a


typeAliasDuplicate : comparable -> a -> a -> Dict.Dict comparable a -> Dict.Dict comparable a
typeAliasDuplicate k v v2 =
    if v /= v2 then
        Debug.crash ("You can't have two different type aliases for " ++ toString k)
    else
        Dict.insert k v


getContext : List Statement -> ( Maybe Context, List Statement )
getContext statements =
    case statements of
        [] ->
            ( Nothing, [] )

        mod :: statements ->
            let
                base =
                    ExStatement.moduleStatement mod
            in
                ( Just (ExAlias.getAliases base statements), statements )


aggregateStatements : Statement -> ( Context, String ) -> ( Context, String )
aggregateStatements s ( c, code ) =
    let
        ( newC, newCode ) =
            ExStatement.elixirS c s
    in
        ( newC, code ++ newCode )


getCode : Context -> List Statement -> String
getCode context statements =
    ("# Compiled using Elchemy v" ++ version)
        ++ "\n"
        ++ ("defmodule " ++ context.mod ++ " do")
        ++ glueStart
        ++ ((List.foldl (aggregateStatements) ( context, "" ) statements)
                |> Tuple.second
           )
        ++ glueEnd


parse : String -> String -> List Statement
parse fileName m =
    case Ast.parse (prepare m) of
        Ok ( _, _, statements ) ->
            statements

        Err ( (), { input, position }, [ msg ] ) ->
            Debug.crash
                ("]ERR> Compilation error in:\n "
                    ++ fileName
                    ++ "\nat:\n "
                    ++ (input
                            |> String.lines
                            |> List.take 30
                            |> String.join "\n"
                       )
                    ++ "\n"
                )

        err ->
            Debug.crash (toString err)


prepare : String -> String
prepare codebase =
    codebase |> removeComments


removeComments : String -> String
removeComments =
    -- Need to remove the second one
    Regex.replace All (regex "\\s--.*\n") (always "")
        >> Regex.replace All (regex "\n +\\w+ : .*") (always "")
>>>>src/ExAlias.elm
module ExAlias exposing (..)

import List exposing (..)
import Ast.Statement exposing (..)
import Dict exposing (Dict)
import ExContext
    exposing
        ( Context
        , Alias
        , AliasType
        , Aliases
        , noParamAlias
        , wrongArityAlias
        )


getAliases : Context -> List Statement -> Context
getAliases c list =
    foldl registerAlias c list


registerAlias : Statement -> Context -> Context
registerAlias s c =
    case s of
        TypeDeclaration (TypeConstructor [ name ] arguments) a ->
            { c
                | aliases =
                    c.aliases
                        |> Dict.insert
                            name
                            (Alias c.mod
                                (length arguments)
                                ExContext.Type
                                (TypeVariable ("@" ++ name))
                                (\_ -> (TypeVariable ("@" ++ name)))
                            )
                , types =
                    foldl
                        (\t acc ->
                            case t of
                                TypeConstructor [ name ] args ->
                                    Dict.insert name (length args) acc

                                any ->
                                    Debug.crash "Type can only start with a tag"
                        )
                        c.types
                        a
            }

        (TypeDeclaration _ _) as ts ->
            Debug.crash ("Wrong type declaration " ++ toString ts)

        TypeAliasDeclaration (TypeConstructor [ name ] arguments) a ->
            -- We need to register every type argument as an alias in the context
            { c
                | aliases =
                    Dict.insert name
                        (Alias c.mod
                            (length arguments)
                            ExContext.TypeAlias
                            a
                            (replaceAliasArgs name arguments a)
                        )
                        c.aliases
            }

        (TypeAliasDeclaration _ _) as ts ->
            Debug.crash ("Wrong type alias declaration " ++ toString ts)

        _ ->
            c


replaceAliasArgs : String -> List Type -> Type -> (List Type -> Type)
replaceAliasArgs name expectedArgs return =
    (\givenArgs ->
        let
            arity =
                length givenArgs

            expected =
                length expectedArgs
        in
            if arity == expected then
                resolveTypes expectedArgs givenArgs return
            else
                wrongArityAlias expected givenArgs name
    )


resolveTypes : List Type -> List Type -> Type -> Type
resolveTypes expected given return =
    let
        expectedName n =
            case n of
                TypeVariable name ->
                    name

                other ->
                    Debug.crash
                        ("type can only take variables. "
                            ++ toString other
                            ++ "is incorrect"
                        )

        paramsWithResolution =
            map2 (,) (map expectedName expected) given
                |> foldl (uncurry Dict.insert) Dict.empty

        replace t =
            case t of
                (TypeVariable name) as default ->
                    Dict.get name paramsWithResolution
                        |> Maybe.withDefault default

                TypeConstructor names args ->
                    TypeConstructor names (map replace args)

                TypeRecordConstructor name args ->
                    TypeRecordConstructor (replace name) (map (Tuple.mapSecond replace) args)

                -- AST eror workaround
                TypeTuple [ arg ] ->
                    replace arg

                TypeTuple args ->
                    TypeTuple (map replace args)

                TypeRecord args ->
                    TypeRecord (map (Tuple.mapSecond replace) args)

                TypeApplication l r ->
                    TypeApplication (replace l) (replace r)
    in
        replace return


maybeAlias : Aliases -> String -> Maybe Alias
maybeAlias aliases name =
    Dict.get name aliases
>>>>src/ExContext.elm
module ExContext exposing (..)

import Ast.Statement exposing (ExportSet, Type(..))
import Dict exposing (Dict)


type alias Aliases =
    Dict String Alias


type AliasType
    = Type
    | TypeAlias


type alias Alias =
    { mod : String
    , arity : Int
    , aliasType : AliasType
    , body : Type
    , getTypeBody : List Type -> Type
    }


noParamAlias : Type -> (List Type -> Type)
noParamAlias return params =
    case ( return, params ) of
        ( _, [] ) ->
            return

        ( TypeVariable name, other ) ->
            wrongArityAlias 0 other name

        other ->
            Debug.crash ("Wrong alias defintion " ++ toString other)


wrongArityAlias : Int -> List Type -> String -> a
wrongArityAlias arity list name =
    "Expected "
        ++ toString arity
        ++ " arguments for "
        ++ name
        ++ ". But got "
        ++ (toString <| List.length list)
        |> Debug.crash


type alias Flag =
    ( String, String )


type alias Definition =
    { arity : Int, def : Type }


type alias Context =
    { mod : String
    , exports : ExportSet
    , indent : Int
    , aliases : Aliases
    , types : Dict String Int
    , flags : List Flag
    , definitions : Dict String Definition
    }


empty : String -> ExportSet -> Context
empty name exports =
    Context name exports 0 Dict.empty Dict.empty [] Dict.empty


indent : Context -> Context
indent c =
    { c | indent = c.indent + 1 }


deindent : Context -> Context
deindent c =
    { c | indent = c.indent - 1 }


addFlag : Flag -> Context -> Context
addFlag flag c =
    { c | flags = flag :: c.flags }


onlyWithoutFlag : Context -> String -> String -> String -> String
onlyWithoutFlag c key value code =
    if hasFlag key value c then
        ""
    else
        code


getAllFlags : String -> Context -> List String
getAllFlags key c =
    c.flags
        |> List.filter (Tuple.first >> ((==) key))
        |> List.map Tuple.second


hasFlag : String -> String -> Context -> Bool
hasFlag key value c =
    c.flags
        |> List.any ((==) ( key, value ))
>>>>src/ExExpression.elm
module ExExpression exposing (..)

import Ast.Expression exposing (..)
import Helpers exposing (..)
import Ast.Statement exposing (..)
import ExContext exposing (Context, indent, deindent, onlyWithoutFlag)
import List exposing (..)
import ExAlias
import ExType
import Dict


elixirE : Context -> Expression -> String
elixirE c e =
    case e of
        Variable var ->
            elixirVariable c var

        -- Primitive types
        (Application name arg) as application ->
            (tupleOrFunction c application)

        RecordUpdate name keyValuePairs ->
            "%{"
                ++ toSnakeCase True name
                ++ " | "
                ++ (map (\( a, b ) -> a ++ ": " ++ elixirE c b) keyValuePairs
                        |> String.join ", "
                   )
                ++ "}"

        -- Primitive operators
        Access ((Variable modules) as left) right ->
            modulePath modules
                ++ "."
                ++ String.join "." (map (toSnakeCase True) right)

        Access left right ->
            elixirE c left
                ++ "."
                ++ String.join "." right

        AccessFunction name ->
            "(fn a -> a." ++ toSnakeCase True name ++ " end)"

        -- Basic operators that are functions in Elixir
        -- Exception, ( "//", "" )
        -- Exception, ( "%", "" )
        -- Exception, ( "rem", "" )
        -- Exception, ( "^", "" )
        -- Tuple is an exception
        BinOp (Variable [ op ]) l r ->
            elixirBinop c op l r

        -- Rest
        e ->
            elixirControlFlow c e


elixirControlFlow : Context -> Expression -> String
elixirControlFlow c e =
    case e of
        Case var body ->
            caseE c var body

        Lambda args body ->
            lambda c args body

        (If check onTrue ((If _ _ _) as onFalse)) as exp ->
            "cond do"
                :: handleIfExp (indent c) exp
                ++ [ ind c.indent, "end" ]
                |> String.join ""

        If check onTrue onFalse ->
            "if "
                ++ elixirE c check
                ++ " do "
                ++ elixirE c onTrue
                ++ " else "
                ++ elixirE c onFalse
                ++ " end"

        Let variables expression ->
            variables
                |> map
                    (\( var, exp ) ->
                        case applicationToList var of
                            [ Variable [ name ] ] ->
                                toSnakeCase True name
                                    ++ " = "
                                    ++ elixirE c exp

                            (Variable [ name ]) :: args ->
                                toSnakeCase True name
                                    ++ " = "
                                    ++ produceLambda c args exp

                            [ assign ] ->
                                elixirE c assign
                                    ++ " = "
                                    ++ elixirE c exp

                            _ ->
                                Debug.crash "Impossible"
                    )
                |> String.join (ind c.indent)
                |> flip (++) (ind c.indent ++ elixirE c expression)

        _ ->
            elixirTypeInstances c e


elixirTypeInstances : Context -> Expression -> String
elixirTypeInstances c e =
    case e of
        Integer value ->
            toString value

        Float value ->
            let
                name =
                    toString value
            in
                if String.contains "." name then
                    name
                else
                    name ++ ".0"

        Character value ->
            toString value

        String value ->
            unescape (toString value)

        List vars ->
            "["
                ++ (map (elixirE c) vars
                        |> String.join ", "
                   )
                ++ "]"

        Tuple vars ->
            "{"
                ++ (map (elixirE c) vars
                        |> String.join ", "
                   )
                ++ "}"

        Record keyValuePairs ->
            "%{"
                ++ (map (\( a, b ) -> a ++ ": " ++ elixirE c b) keyValuePairs
                        |> String.join ", "
                   )
                ++ "}"

        _ ->
            notImplemented "expression" e


handleIfExp : Context -> Expression -> List String
handleIfExp c e =
    case e of
        If check onTrue onFalse ->
            (++)
                [ ind c.indent
                , elixirE (indent c) check
                , " -> "
                , elixirE (indent c) onTrue
                ]
                (handleIfExp c onFalse)

        _ ->
            [ ind c.indent
            , "true -> "
            , elixirE (indent c) e
            ]


getMetaLine : Expression -> String
getMetaLine a =
    case a of
        String line ->
            line

        _ ->
            Debug.crash "Meta function has to have specific format"


generateMeta : Expression -> String
generateMeta e =
    case e of
        List args ->
            (map getMetaLine args
                |> map ((++) (ind 0))
                |> String.join ""
                |> flip (++) "\n"
            )
                ++ "\n"

        _ ->
            Debug.crash "Meta function has to have specific format"


flambdify : Context -> List (List a) -> String
flambdify c argTypes =
    let
        arity =
            length argTypes - 1

        indexes =
            range 1 arity
    in
        map2 (,) indexes argTypes
            |> map
                (\( i, arg ) ->
                    case arg of
                        [] ->
                            Debug.crash "Impossible"

                        [ any ] ->
                            "a" ++ toString i

                        list ->
                            resolveFfi c (Flambda (length list - 1) (Variable [ "a" ++ toString i ]))
                )
            |> String.join ", "


generateFfi : Context -> String -> List (List Type) -> Expression -> String
generateFfi c name argTypes e =
    let
        typeDef =
            c.definitions |> Dict.get name

        appList =
            applicationToList e

        flambdaArguments =
            flambdify c argTypes
    in
        case ( typeDef, applicationToList e ) of
            ( Nothing, _ ) ->
                Debug.crash "Ffi requires type definition"

            ( Just def, [ Variable [ "ffi" ], String mod, String fun ] ) ->
                functionCurry c name def.arity
                    ++ (onlyWithoutFlag c
                            "noverify"
                            name
                            (ind c.indent
                                ++ "verify as: "
                                ++ mod
                                ++ "."
                                ++ fun
                                ++ "/"
                                ++ toString def.arity
                            )
                       )
                    ++ ind c.indent
                    ++ "def "
                    ++ toSnakeCase True name
                    ++ "("
                    ++ (generateArguments_ "a" def.arity |> String.join ", ")
                    ++ ")"
                    ++ ", do: "
                    ++ mod
                    ++ "."
                    ++ fun
                    ++ "("
                    ++ flambdaArguments
                    ++ ")"

            ( Just def, [ Variable [ "tryFfi" ], String mod, String fun ] ) ->
                functionCurry c name def.arity
                    ++ ind c.indent
                    ++ "def "
                    ++ toSnakeCase True name
                    ++ "("
                    ++ (generateArguments_ "a" def.arity |> String.join ", ")
                    ++ ")"
                    ++ " do "
                    ++ ind (c.indent + 1)
                    ++ "try_catch fn -> "
                    ++ ind (c.indent + 2)
                    ++ mod
                    ++ "."
                    ++ fun
                    ++ "("
                    ++ flambdaArguments
                    ++ ")"
                    ++ ind (c.indent + 1)
                    ++ "end"
                    ++ ind c.indent
                    ++ "end"

            _ ->
                Debug.crash "Wrong ffi definition"


combineComas : Context -> Expression -> String
combineComas c e =
    flattenCommas e
        |> map (elixirE c)
        |> String.join ", "


flattenCommas : Expression -> List Expression
flattenCommas e =
    case e of
        Tuple kvs ->
            kvs

        a ->
            [ a ]


flattenPipes : Expression -> List Expression
flattenPipes e =
    case e of
        BinOp (Variable [ "|>" ]) l ((BinOp (Variable [ "|>" ]) r _) as n) ->
            [ l ] ++ flattenPipes n

        BinOp (Variable [ "|>" ]) l r ->
            [ l ] ++ [ r ]

        other ->
            [ other ]


isMacro : Expression -> Bool
isMacro e =
    case e of
        Application a _ ->
            isMacro a

        Variable [ "tryFfi" ] ->
            True

        Variable [ "ffi" ] ->
            True

        Variable [ "lffi" ] ->
            True

        Variable [ "flambda" ] ->
            True

        other ->
            False


flattenApplication : Expression -> List Expression
flattenApplication application =
    case application of
        Application left right ->
            if isMacro application then
                (flattenApplication left) ++ [ right ]
            else if isTuple application then
                (flattenApplication left) ++ [ right ]
            else
                [ application ]

        other ->
            [ other ]


applicationToList : Expression -> List Expression
applicationToList application =
    case application of
        Application left right ->
            (applicationToList left) ++ [ right ]

        other ->
            [ other ]


tupleOrFunction : Context -> Expression -> String
tupleOrFunction c a =
    case flattenApplication a of
        (Application left right) :: [] ->
            elixirE c left ++ ".(" ++ elixirE c right ++ ")"

        (Variable [ "ffi" ]) :: rest ->
            Debug.crash "Ffi inside function body is deprecated since Elchemy 0.3"

        (Variable [ "tryFfi" ]) :: rest ->
            Debug.crash "tryFfi inside function body is deprecated since Elchemy 0.3"

        (Variable [ "lffi" ]) :: rest ->
            Debug.crash "Lffi inside function body is deprecated since Elchemy 0.3"

        (Variable [ "flambda" ]) :: rest ->
            Debug.crash "Flambda is deprecated since Elchemy 0.3"

        [ Variable [ "Just" ], arg ] ->
            "{" ++ elixirE c arg ++ "}"

        [ Variable [ "Ok" ], arg ] ->
            if arg == Variable [ "()" ] then
                ":ok"
            else
                "{:ok, " ++ elixirE c arg ++ "}"

        [ Variable [ "Err" ], arg ] ->
            "{:error, " ++ elixirE c arg ++ "}"

        (Variable list) :: rest ->
            case lastAndRest list of
                ( Just last, _ ) ->
                    aliasFor c last rest
                        |> Maybe.withDefault
                            ("{"
                                ++ elixirE c (Variable [ last ])
                                ++ ", "
                                ++ (map (elixirE c) rest |> String.join ", ")
                                ++ "}"
                            )

                _ ->
                    Debug.crash "Won't ever happen"

        other ->
            Debug.crash ("Shouldn't ever work for" ++ toString other)


aliasFor : Context -> String -> List Expression -> Maybe String
aliasFor c name rest =
    ExAlias.maybeAlias c.aliases name
        |> Maybe.andThen
            (\({ aliasType } as ali) ->
                case aliasType of
                    ExContext.TypeAlias ->
                        Just ali

                    ExContext.Type ->
                        Nothing
            )
        |> Maybe.andThen (ExType.typealiasConstructor [])
        |> Maybe.map
            ((elixirE c)
                >> (++) "("
                >> flip (++)
                    (rest
                        |> map (elixirE c)
                        |> String.join ").("
                        |> (++) ").("
                        |> flip (++) ")"
                    )
            )
        |> maybeOr
            (Dict.get name c.types
                |> Maybe.map
                    (\arity ->
                        let
                            len =
                                length rest

                            dif =
                                arity - len

                            arguments =
                                generateArguments dif

                            varArgs =
                                map (singleton >> Variable) arguments
                        in
                            if arity == 0 then
                                atomize name
                            else if dif >= 0 then
                                arguments
                                    |> map ((++) " fn ")
                                    |> map (flip (++) " ->")
                                    |> String.join ""
                                    |> flip (++)
                                        (" {"
                                            ++ atomize name
                                            ++ ", "
                                            ++ (map (elixirE c) (rest ++ varArgs) |> String.join ", ")
                                            ++ "}"
                                        )
                                    |> flip (++) (String.repeat dif " end ")
                            else
                                Debug.crash
                                    ("Expected "
                                        ++ toString arity
                                        ++ " arguments for '"
                                        ++ name
                                        ++ "'. Got: "
                                        ++ toString (length rest)
                                    )
                    )
            )


type Ffi
    = Lffi Expression Expression
    | Ffi Expression Expression Expression
    | TryFfi Expression Expression Expression
    | Flambda Int Expression


resolveFfi : Context -> Ffi -> String
resolveFfi c ffi =
    case ffi of
        TryFfi (String mod) (String fun) ((Tuple _) as args) ->
            "try_catch fn _ -> "
                ++ mod
                ++ "."
                ++ fun
                ++ "("
                ++ combineComas c args
                ++ ")"
                ++ " end"

        -- One or many arg fun
        TryFfi (String mod) (String fun) any ->
            "try_catch fn _ -> "
                ++ mod
                ++ "."
                ++ fun
                ++ "("
                ++ elixirE c any
                ++ ")"
                ++ " end"

        -- Elchemy hack
        Ffi (String mod) (String fun) ((Tuple _) as args) ->
            mod ++ "." ++ fun ++ "(" ++ combineComas c args ++ ")"

        -- One or many arg fun
        Ffi (String mod) (String fun) any ->
            mod ++ "." ++ fun ++ "(" ++ elixirE c any ++ ")"

        -- Elchemy hack
        Lffi (String fun) ((Tuple _) as args) ->
            fun ++ "(" ++ combineComas c args ++ ")"

        -- One arg fun
        Lffi (String fun) any ->
            fun ++ "(" ++ elixirE c any ++ ")"

        Flambda arity fun ->
            let
                args =
                    generateArguments arity
            in
                "fn ("
                    ++ String.join "," args
                    ++ ") -> "
                    ++ elixirE c fun
                    ++ (map (\a -> ".(" ++ a ++ ")") args
                            |> String.join ""
                       )
                    ++ " end"

        _ ->
            Debug.crash "Wrong ffi call"


isTuple : Expression -> Bool
isTuple a =
    case a of
        Application a _ ->
            isTuple a

        Variable [ "()" ] ->
            True

        Variable [ name ] ->
            isUpper name

        Variable list ->
            case lastAndRest list of
                ( Just last, _ ) ->
                    isTuple (Variable [ last ])

                _ ->
                    Debug.crash "Shouldn't ever happen"

        other ->
            False


caseE : Context -> Expression -> List ( Expression, Expression ) -> String
caseE c var body =
    "case "
        ++ elixirE c var
        ++ " do"
        ++ (String.join ""
                (List.map (caseInstance c) body)
           )
        ++ ind (c.indent)
        ++ "end"


caseInstance : Context -> ( Expression, Expression ) -> String
caseInstance c a =
    (ind (c.indent + 1) ++ elixirE c (Tuple.first a))
        ++ " ->"
        ++ (ind (c.indent + 2))
        ++ (elixirE c (Tuple.second a))


lambda : Context -> List Expression -> Expression -> String
lambda c args body =
    case args of
        arg :: rest ->
            "fn("
                ++ elixirE c arg
                ++ ") -> "
                ++ lambda c rest body
                ++ " end"

        [] ->
            elixirE c body


genElixirFunc : Context -> String -> List Expression -> Expression -> String
genElixirFunc c name args body =
    case ( isOperator name, args ) of
        ( Builtin, [ l, r ] ) ->
            (ind c.indent)
                ++ "def"
                ++ privateOrPublic c name
                ++ " "
                ++ elixirE c l
                ++ " "
                ++ translateOperator name
                ++ " "
                ++ elixirE c r
                ++ " do"
                ++ (ind <| c.indent + 1)
                ++ elixirE (indent c) body
                ++ ind c.indent
                ++ "end"

        ( Custom, _ ) ->
            (ind c.indent)
                ++ "def"
                ++ privateOrPublic c name
                ++ " "
                ++ translateOperator name
                ++ "("
                ++ (args
                        |> List.map (elixirE c)
                        |> String.join ", "
                   )
                ++ ") do"
                ++ (ind <| c.indent + 1)
                ++ elixirE (indent c) body
                ++ ind c.indent
                ++ "end"

        ( Builtin, _ ) ->
            Debug.crash
                ("operator " ++ name ++ " has to have 2 arguments but has " ++ toString args)

        ( None, _ ) ->
            (ind c.indent)
                ++ "def"
                ++ privateOrPublic c name
                ++ " "
                ++ toSnakeCase True name
                ++ "("
                ++ (args
                        |> List.map (elixirE c)
                        |> String.join ", "
                   )
                ++ ") do"
                ++ (ind <| c.indent + 1)
                ++ elixirE (indent c) body
                ++ ind c.indent
                ++ "end"


privateOrPublic : Context -> String -> String
privateOrPublic context name =
    case context.exports of
        SubsetExport exports ->
            if any (\exp -> exp == FunctionExport name) exports then
                ""
            else
                "p"

        AllExport ->
            ""

        other ->
            Debug.crash "No such export"


functionCurry : Context -> String -> Int -> String
functionCurry c name arity =
    case ( arity, ExContext.hasFlag "nocurry" name c ) of
        ( 0, _ ) ->
            ""

        ( _, True ) ->
            ""

        ( arity, False ) ->
            let
                resolvedName =
                    if isOperator name == Custom then
                        translateOperator name
                    else
                        toSnakeCase True name
            in
                (ind c.indent)
                    ++ "curry"
                    ++ privateOrPublic c name
                    ++ " "
                    ++ resolvedName
                    ++ "/"
                    ++ toString arity


genFunctionDefinition : Context -> String -> List Expression -> Expression -> String
genFunctionDefinition c name args body =
    if ExContext.hasFlag "nodef" name c then
        functionCurry c name (length args)
    else
        functionCurry c name (length args)
            ++ genElixirFunc c name args body
            ++ "\n"


genOverloadedFunctionDefinition :
    Context
    -> String
    -> List Expression
    -> Expression
    -> List ( Expression, Expression )
    -> String
genOverloadedFunctionDefinition c name args body expressions =
    if ExContext.hasFlag "nodef" name c then
        functionCurry c name (length args)
    else
        functionCurry c name (length args)
            ++ (expressions
                    |> List.map
                        (\( left, right ) ->
                            genElixirFunc
                                c
                                name
                                [ left ]
                                right
                        )
                    |> List.foldr (++) ""
                    |> flip (++) "\n"
               )


getVariableName : Expression -> String
getVariableName e =
    case e of
        Variable [ name ] ->
            name

        _ ->
            Debug.crash "It's not a variable"


elixirVariable : Context -> List String -> String
elixirVariable c var =
    case var of
        [] ->
            ""

        [ "()" ] ->
            "{}"

        [ "Nothing" ] ->
            "nil"

        [ "curry" ] ->
            "curried"

        [ "uncurry" ] ->
            "uncurried"

        [ name ] ->
            if isCapitilzed name then
                aliasFor c name []
                    |> Maybe.withDefault (atomize name)
            else if String.startsWith "@" name then
                String.dropLeft 1 name
                    |> atomize
            else
                case isOperator name of
                    Builtin ->
                        -- We need a curried version, so kernel won't work
                        if name == "<|" then
                            "flip.((&|>/0).())"
                        else
                            "(&" ++ translateOperator name ++ "/0).()"

                    Custom ->
                        translateOperator name

                    None ->
                        toSnakeCase True name

        list ->
            case lastAndRest list of
                ( Just last, rest ) ->
                    elixirE c (Variable [ last ])

                _ ->
                    Debug.crash "Shouldn't ever happen"
                        String.join
                        "."
                        list


elixirBinop : Context -> String -> Expression -> Expression -> String
elixirBinop c op l r =
    case op of
        "//" ->
            "div(" ++ elixirE c l ++ ", " ++ elixirE c r ++ ")"

        "%" ->
            "rem(" ++ elixirE c l ++ ", " ++ elixirE c r ++ ")"

        "^" ->
            ":math.pow(" ++ elixirE c l ++ ", " ++ elixirE c r ++ ")"

        "::" ->
            "["
                ++ elixirE c l
                ++ " | "
                ++ elixirE c r
                ++ "]"

        "<<" ->
            elixirBinop c ">>" r l

        "<|" ->
            elixirBinop c "|>" r l

        "|>" ->
            elixirE c l
                ++ (flattenPipes r
                        |> map (elixirE c)
                        |> map ((++) (ind c.indent ++ "|> ("))
                        |> map (flip (++) ").()")
                        |> String.join ""
                   )

        op ->
            case isOperator op of
                Builtin ->
                    [ "(", elixirE c l, translateOperator op, elixirE c r, ")" ]
                        |> String.join " "

                Custom ->
                    (translateOperator op)
                        ++ "("
                        ++ elixirE c l
                        ++ ", "
                        ++ elixirE c r
                        ++ ")"

                None ->
                    Debug.crash ("Illegal operator " ++ op)


produceLambda : Context -> List Expression -> Expression -> String
produceLambda c args body =
    case args of
        arg :: rest ->
            "fn("
                ++ (elixirE c arg)
                ++ ") -> "
                ++ produceLambda c rest body
                ++ " end"

        [] ->
            elixirE c body
>>>>src/ExReserved.elm
module ExReserved exposing (..)


ops : List ( Int, Char )
ops =
    [ '+', '-', '/', '*', '=', '.', '$', '<', '>', ':', '&', '|', '^', '?', '%', '#', '@', '~', '!' ] |> List.indexedMap (,)


maybeReplaceStd : String -> String
maybeReplaceStd s =
    if isStdModule s then
        "X" ++ s
    else if s == "Native" then
        Debug.crash
            ("Compile found out you're using Native modules in the codebase."
                ++ "Elchemy doesn't support Elm Native Modules since they're JavaScript"
            )
    else
        s


isStdModule : String -> Bool
isStdModule a =
    List.member a
        [ "Basics"
        , "List"
        , "String"
        , "Maybe"
        , "Char"
        , "Result"
        , "Tuple"
        ]


reservedWords : List String
reservedWords =
    [ "fn", "do", "end" ]


replaceOp : String -> String
replaceOp op =
    String.toList op
        |> List.map replaceOp_
        |> String.join ""
        |> flip (++) "__"


replaceOp_ : Char -> String
replaceOp_ op =
    case
        List.filter (\( i, o ) -> op == o) ops
    of
        ( index, _ ) :: _ ->
            "op" ++ toString index

        _ ->
            Debug.crash "Illegal op"


maybeReplaceReserved : String -> String
maybeReplaceReserved a =
    if List.member a reservedWords then
        a ++ "__"
    else
        a
>>>>src/ExStatement.elm
module ExStatement exposing (..)

import Ast
import Ast.Statement exposing (..)
import Ast.Expression exposing (..)
import Ast.BinOp exposing (operators)
import ExContext exposing (Context, Definition, indent, deindent, onlyWithoutFlag)
import ExExpression
import ExType
import Helpers exposing (..)
import List exposing (..)
import Dict exposing (Dict)
import Regex exposing (..)
import Helpers exposing (..)
import Debug exposing (crash)


type ElchemyComment
    = Doc String
    | Ex String
    | Normal String
    | Flag String


moduleStatement : Statement -> Context
moduleStatement s =
    case s of
        ModuleDeclaration names exports ->
            ExContext.empty (String.join "." names) exports

        other ->
            crash "First statement must be module declaration"


elixirS : Context -> Statement -> ( Context, String )
elixirS c s =
    case s of
        InfixDeclaration _ _ _ ->
            ( c, "" )

        TypeDeclaration (TypeConstructor [ name ] _) types ->
            (,) c <|
                (ind c.indent)
                    ++ "@type "
                    ++ toSnakeCase True name
                    ++ " :: "
                    ++ (map (ExType.uniontype c) types |> String.join " | ")
                    ++ "\n"

        TypeAliasDeclaration _ _ ->
            ( c, "" )

        (FunctionTypeDeclaration name ((TypeApplication _ _) as t)) as def ->
            let
                definition =
                    getTypeDefinition def
            in
                (,) (addTypeDefinition c name definition) <|
                    case isOperator name of
                        Builtin ->
                            -- TODO implement operator specs
                            ""

                        Custom ->
                            -- onlyWithoutFlag c
                            -- "nospec0"
                            -- name
                            -- ((ind c.indent)
                            --     ++ "@spec "
                            --     ++ translateOperator name
                            --     ++ (ExType.typespec0 c t)
                            -- )
                            onlyWithoutFlag c
                                "nospec"
                                name
                                ""
                                ++ ((ind c.indent)
                                        ++ "@spec "
                                        ++ translateOperator name
                                        ++ (ExType.typespec c t)
                                   )

                        None ->
                            -- onlyWithoutFlag c
                            --     "nospec0"
                            --     name
                            --     ((ind c.indent)
                            --         ++ "@spec "
                            --         ++ toSnakeCase True name
                            --         ++ (ExType.typespec0 c t)
                            --     )
                            onlyWithoutFlag c
                                "nospec"
                                name
                                ((ind c.indent)
                                    ++ "@spec "
                                    ++ toSnakeCase True name
                                    ++ (ExType.typespec c t)
                                )

        (FunctionTypeDeclaration name t) as def ->
            let
                definition =
                    getTypeDefinition def
            in
                (,) (addTypeDefinition c name definition) <|
                    case isOperator name of
                        Builtin ->
                            -- TODO implement operator specs
                            ""

                        Custom ->
                            onlyWithoutFlag c
                                name
                                "nospec"
                                ((ind c.indent)
                                    ++ "@spec "
                                    ++ translateOperator name
                                    ++ (ExType.typespec c t)
                                )

                        None ->
                            onlyWithoutFlag c
                                name
                                "nospec"
                                ((ind c.indent)
                                    ++ "@spec "
                                    ++ toSnakeCase True name
                                    ++ (ExType.typespec c t)
                                )

        (FunctionDeclaration name args body) as fd ->
            (,) c <|
                if name == "meta" && args == [] then
                    ExExpression.generateMeta body
                else
                    case body of
                        Access (Variable ("Native" :: rest)) [ call ] ->
                            ExExpression.generateFfi
                                c
                                name
                                (c.definitions
                                    |> Dict.get name
                                    |> Maybe.map
                                        (.def
                                            >> typeAplicationToList
                                        )
                                    |> Maybe.withDefault []
                                    |> map typeAplicationToList
                                )
                                (Application
                                    (Application (Variable [ "ffi" ])
                                        (String (String.join "." rest))
                                    )
                                    (String call)
                                )

                        (Application (Application (Variable [ "ffi" ]) _) _) as app ->
                            ExExpression.generateFfi
                                c
                                name
                                (c.definitions
                                    |> Dict.get name
                                    |> Maybe.map
                                        (.def
                                            >> typeAplicationToList
                                        )
                                    |> Maybe.withDefault []
                                    |> map typeAplicationToList
                                )
                                app

                        (Application (Application (Variable [ "tryFfi" ]) _) _) as app ->
                            ExExpression.generateFfi
                                c
                                name
                                (c.definitions
                                    |> Dict.get name
                                    |> Maybe.map
                                        (.def
                                            >> typeAplicationToList
                                        )
                                    |> Maybe.withDefault []
                                    |> map typeAplicationToList
                                )
                                app

                        Case vars expressions ->
                            if ExExpression.flattenCommas vars == args then
                                ExExpression.genOverloadedFunctionDefinition
                                    c
                                    name
                                    args
                                    body
                                    expressions
                            else
                                ExExpression.genFunctionDefinition
                                    c
                                    name
                                    args
                                    body

                        _ ->
                            ExExpression.genFunctionDefinition
                                c
                                name
                                args
                                body

        Comment content ->
            case getCommentType content of
                Doc content ->
                    (,) c <|
                        (ind c.indent)
                            ++ "@doc \"\"\"\n "
                            ++ (content
                                    |> String.lines
                                    |> map (maybeDoctest c)
                                    |> map (Helpers.escape)
                                    |> map (flip (++) (ind c.indent))
                                    |> map trimIndentations
                                    |> String.join ""
                                    -- Drop an unnecessary \n at the end
                                    |> String.dropRight 1
                               )
                            ++ (ind c.indent)
                            ++ "\"\"\""

                Ex content ->
                    (,) c <|
                        (content
                            |> String.split "\n"
                            |> map String.trim
                            |> String.join "\n"
                            |> indAll c.indent
                        )

                Flag content ->
                    flip (,) "" <|
                        (content
                            |> Regex.split All (regex "\\s+")
                            |> map (String.split ":+")
                            |> filterMap
                                (\flag ->
                                    case flag of
                                        [ k, v ] ->
                                            Just ( k, v )

                                        [ "" ] ->
                                            Nothing

                                        a ->
                                            crash ("Wrong flag format " ++ toString a)
                                )
                            |> foldl (ExContext.addFlag) c
                        )

                Normal content ->
                    (,) c <|
                        (content
                            |> prependAll ("# ")
                            |> indAll c.indent
                        )

        -- That's not a real import. In elixir it's called alias
        ImportStatement path Nothing Nothing ->
            (,) c <|
                (ind c.indent)
                    ++ "alias "
                    ++ modulePath path

        ImportStatement path (Just asName) Nothing ->
            (,) c <|
                (ind c.indent)
                    ++ "alias "
                    ++ modulePath path
                    ++ ", as: "
                    ++ asName

        ImportStatement path Nothing (Just (SubsetExport exports)) ->
            (,) c <|
                (ind c.indent)
                    ++ "import "
                    ++ modulePath path
                    ++ ", only: ["
                    ++ (map subsetExport exports |> foldl (++) [] |> String.join ",")
                    ++ "]"

        ImportStatement path Nothing (Just AllExport) ->
            (,) c <|
                (ind c.indent)
                    ++ "import "
                    ++ modulePath path

        s ->
            (,) c <|
                notImplemented "statement" s


getCommentType : String -> ElchemyComment
getCommentType comment =
    [ ( "^\\sex\\b", (Ex) )
    , ( "^\\|", (Doc) )
    , ( "^\\sflag\\b", (Flag) )
    ]
        |> List.map (\( a, b ) -> ( Regex.regex a, b ))
        |> List.foldl findCommentType (Normal comment)


findCommentType : ( Regex.Regex, String -> ElchemyComment ) -> ElchemyComment -> ElchemyComment
findCommentType ( regex, commentType ) acc =
    case acc of
        Normal content ->
            if Regex.contains regex content then
                commentType <|
                    Regex.replace (Regex.AtMost 1) regex (always "") content
            else
                Normal content

        other ->
            other


subsetExport : ExportSet -> List String
subsetExport exp =
    case exp of
        TypeExport _ _ ->
            []

        FunctionExport name ->
            [ "{:'" ++ name ++ "', 0}" ]

        _ ->
            crash ("You can't export " ++ toString exp)


maybeDoctest : Context -> String -> String
maybeDoctest c line =
    if String.startsWith (ind (c.indent + 1)) ("\n" ++ line) then
        case Ast.parseExpression Ast.BinOp.operators (String.trim line) of
            Ok ( _, _, BinOp (Variable [ "==" ]) l r ) ->
                ind (c.indent + 2)
                    ++ "iex> import "
                    ++ c.mod
                    ++ ind (c.indent + 2)
                    ++ "iex> "
                    ++ ExExpression.elixirE c l
                    ++ ind (c.indent + 2)
                    ++ ExExpression.elixirE c r

            _ ->
                line
    else
        line


getTypeDefinition : Statement -> Definition
getTypeDefinition a =
    case a of
        FunctionTypeDeclaration name t ->
            let
                arity =
                    typeAplicationToList t |> length
            in
                Definition (arity - 1) t

        _ ->
            Debug.crash "It's not a type declaration"


addTypeDefinition : Context -> String -> Definition -> Context
addTypeDefinition c name d =
    { c
        | definitions =
            Dict.insert name
                d
                c.definitions
    }


typeAplicationToList : Type -> List Type
typeAplicationToList application =
    case application of
        TypeApplication left right ->
            [ left ] ++ typeAplicationToList right

        other ->
            [ other ]
>>>>src/ExType.elm
module ExType exposing (..)

import Ast.Statement exposing (..)
import Ast.Expression exposing (..)
import Helpers exposing (..)
import List exposing (..)
import ExContext exposing (Context, indent)
import ExAlias


flattenTypeApplication : Type -> List Type
flattenTypeApplication application =
    case application of
        TypeApplication left right ->
            left :: flattenTypeApplication right

        other ->
            [ other ]


elixirTFlat : Context -> Type -> String
elixirTFlat =
    elixirT True


elixirTNoFlat : Context -> Type -> String
elixirTNoFlat =
    elixirT False


find : (a -> Bool) -> List a -> Maybe a
find f list =
    list
        |> foldl
            (\a acc ->
                if f a then
                    Just a
                else
                    acc
            )
            Nothing


elixirT : Bool -> Context -> Type -> String
elixirT flatten c t =
    case t of
        TypeTuple [] ->
            "no_return"

        TypeTuple [ a ] ->
            elixirT flatten c a

        TypeTuple ((a :: rest) as list) ->
            "{"
                ++ (map (elixirT flatten c) list
                        |> String.join ", "
                   )
                ++ "}"

        TypeVariable "number" ->
            "number"

        (TypeVariable name) as var ->
            case String.uncons name of
                Just ( '@', name ) ->
                    toSnakeCase True name

                any ->
                    "any"

        TypeConstructor [ t ] any ->
            elixirTypeConstructor flatten c t any

        TypeConstructor t args ->
            case lastAndRest t of
                ( Just last, a ) ->
                    ExAlias.maybeAlias c.aliases last
                        |> Maybe.andThen
                            (\ali ->
                                if ali.aliasType == ExContext.TypeAlias then
                                    Just ali
                                else
                                    Nothing
                            )
                        |> Maybe.map (\{ getTypeBody } -> getTypeBody args)
                        |> Maybe.map (elixirT flatten c)
                        |> Maybe.withDefault
                            (String.join
                                "."
                                a
                                ++ "."
                                ++ toSnakeCase True last
                            )

                _ ->
                    Debug.crash "Shouldn't ever happen"

        TypeRecord fields ->
            "%{"
                ++ ind (c.indent + 1)
                ++ (map
                        (\( k, v ) ->
                            k ++ ": " ++ elixirT flatten (indent c) v
                        )
                        fields
                        |> String.join ("," ++ ind (c.indent + 1))
                   )
                ++ ind (c.indent)
                ++ "}"

        (TypeRecordConstructor _ _) as tr ->
            "%{"
                ++ ind (c.indent + 1)
                ++ ((typeRecordFields (indent c) flatten tr)
                        |> String.join (", " ++ ind (c.indent + 1))
                   )
                ++ ind (c.indent)
                ++ "}"

        TypeApplication l r ->
            if flatten then
                "("
                    ++ (flattenTypeApplication r
                            |> lastAndRest
                            |> \( last, rest ) ->
                                (map (elixirT flatten (indent c)) (l :: rest) |> String.join ", ")
                                    ++ " -> "
                                    ++ (Maybe.map (elixirT flatten c) last |> Maybe.withDefault "")
                       )
                    ++ ")"
            else
                "("
                    ++ elixirT flatten c l
                    ++ " -> "
                    ++ elixirT flatten c r
                    ++ ")"


typeRecordFields : Context -> Bool -> Type -> List String
typeRecordFields c flatten t =
    case t of
        TypeRecordConstructor (TypeConstructor [ name ] args) fields ->
            let
                inherited =
                    ExAlias.maybeAlias c.aliases name
                        |> Maybe.map (\{ getTypeBody } -> getTypeBody args)
                        |> Maybe.map (typeRecordFields c flatten)
            in
                (map
                    (\( k, v ) ->
                        k ++ ": " ++ elixirT flatten c v
                    )
                    (fields)
                )
                    ++ (Maybe.withDefault [ "" ] inherited)

        TypeRecordConstructor (TypeRecord inherited) fields ->
            (map
                (\( k, v ) ->
                    k ++ ": " ++ elixirT flatten c v
                )
                (fields ++ inherited)
            )

        TypeRecordConstructor (TypeVariable _) fields ->
            (map
                (\( k, v ) ->
                    k ++ ": " ++ elixirT flatten c v
                )
                (fields)
            )

        TypeRecordConstructor ((TypeRecordConstructor _ _) as tr) fields ->
            (map
                (\( k, v ) ->
                    k ++ ": " ++ elixirT flatten c v
                )
                (fields)
            )
                ++ typeRecordFields c flatten tr

        any ->
            Debug.crash ("Wrong type record constructor " ++ toString any)


elixirTypeConstructor : Bool -> Context -> String -> List Type -> String
elixirTypeConstructor flatten c name args =
    case ( name, args ) of
        ( "String", [] ) ->
            "String.t"

        ( "Char", [] ) ->
            "char_list"

        ( "Bool", [] ) ->
            "boolean"

        ( "Int", [] ) ->
            "integer"

        ( "Pid", [] ) ->
            "pid"

        ( "Float", [] ) ->
            "float"

        ( "List", [ t ] ) ->
            "list(" ++ elixirT flatten c t ++ ")"

        ( "Maybe", [ t ] ) ->
            "{" ++ elixirT flatten c t ++ "} | nil"

        ( "Nothing", [] ) ->
            "nil"

        ( "Just", [ t ] ) ->
            elixirT flatten c t

        ( "Err", [ t ] ) ->
            "{:error, " ++ elixirT flatten c t ++ "}"

        ( "Ok", [ t ] ) ->
            if t == TypeTuple [] then
                "ok"
            else
                "{:ok," ++ elixirT flatten c t ++ "}"

        ( t, [] ) ->
            aliasOr c t [] (atomize t)

        ( t, list ) ->
            aliasOr
                c
                t
                list
                ("{"
                    ++ atomize t
                    ++ ", "
                    ++ (map (elixirT flatten c) list |> String.join ", ")
                    ++ "}"
                )


typespec0 : Context -> Type -> String
typespec0 c t =
    "() :: " ++ elixirTNoFlat c t


typespec : Context -> Type -> String
typespec c t =
    case lastAndRest (flattenTypeApplication t) of
        ( Just last, args ) ->
            "("
                ++ (map (elixirTNoFlat c) args
                        |> String.join ", "
                   )
                ++ ") :: "
                ++ elixirTNoFlat c last

        ( Nothing, _ ) ->
            Debug.crash "impossible"


uniontype : Context -> Type -> String
uniontype c t =
    case t of
        TypeConstructor [ name ] [] ->
            atomize name

        TypeConstructor [ name ] list ->
            "{"
                ++ atomize name
                ++ ", "
                ++ (map (elixirTNoFlat c) list |> String.join ", ")
                ++ "}"

        other ->
            Debug.crash ("I am looking for union type constructor. But got " ++ toString other)


typealiasConstructor : List a -> ExContext.Alias -> Maybe Expression
typealiasConstructor args ({ mod, aliasType, arity, body, getTypeBody } as ali) =
    case ( aliasType, body ) of
        ( ExContext.Type, _ ) ->
            Nothing

        ( _, TypeConstructor [ name ] _ ) ->
            Nothing

        ( _, TypeRecord kvs ) ->
            let
                args =
                    List.length kvs
                        |> List.range 1
                        |> List.map (toString >> (++) "arg")

                varargs =
                    kvs
                        |> List.map2 (flip (,)) args
                        |> List.map (Tuple.mapFirst Tuple.first)
                        |> List.map
                            (Tuple.mapSecond (singleton >> Variable))
            in
                Just (Lambda (map (singleton >> Variable) args) (Record varargs))

        -- Error in AST. Single TypeTuple are just paren app
        ( _, TypeTuple [ app ] ) ->
            typealiasConstructor args { ali | getTypeBody = (\_ -> app) }

        ( _, TypeTuple kvs ) ->
            let
                args =
                    List.length kvs
                        |> List.range 1
                        |> List.map (toString >> (++) "arg")
                        |> map (singleton >> Variable)
            in
                Just (Lambda (args) (Tuple args))

        ( _, TypeVariable name ) ->
            Just (Variable [ name ])

        other ->
            Nothing


constructApplication : List String -> List Expression
constructApplication list =
    case list of
        [] ->
            Debug.crash "Wrong application"

        [ one ] ->
            [ Variable [ one ] ]

        head :: tail ->
            [ foldl (\a acc -> Application acc (Variable [ a ]))
                (Variable [ head ])
                tail
            ]


aliasOr : Context -> String -> List Type -> String -> String
aliasOr c name args default =
    ExAlias.maybeAlias c.aliases name
        |> Maybe.map
            (\{ mod, getTypeBody, aliasType } ->
                if mod == c.mod then
                    elixirTNoFlat c (getTypeBody args)
                else
                    case aliasType of
                        ExContext.Type ->
                            mod ++ "." ++ elixirTNoFlat c (getTypeBody args)

                        ExContext.TypeAlias ->
                            elixirTNoFlat c (getTypeBody args)
            )
        |> Maybe.withDefault default
>>>>src/Helpers.elm
module Helpers exposing (..)

import Char
import Tuple exposing (..)
import List exposing (..)
import Regex exposing (..)
import Dict exposing (Dict)
import ExReserved


type MaybeUpper
    = Upper String
    | Lower String


notImplemented : String -> a -> String
notImplemented feature value =
    " ## ERROR: No "
        ++ feature
        ++ " implementation for "
        ++ toString value
        ++ " yet"
        ++ "\n"
        |> Debug.crash


toSnakeCase : Bool -> String -> String
toSnakeCase isntAtom s =
    let
        string =
            if isntAtom then
                ExReserved.maybeReplaceReserved s
            else
                s
    in
        if String.toUpper string == string then
            String.toLower string
        else
            string
                |> Regex.split Regex.All (Regex.regex "(?=[A-Z])")
                |> String.join "_"
                |> String.toLower


isUpper : String -> Bool
isUpper string =
    case String.uncons string of
        Just ( start, rest ) ->
            Char.isUpper start

        Nothing ->
            False


capitalize : String -> String
capitalize s =
    String.uncons s
        |> Maybe.map (\a -> String.cons (Char.toUpper (first a)) (second a))
        |> Maybe.withDefault ""


atomize : String -> String
atomize s =
    ":" ++ toSnakeCase False s


isCapitilzed : String -> Bool
isCapitilzed s =
    String.uncons s
        |> Maybe.map (\a -> a |> first |> Char.isUpper)
        |> Maybe.withDefault False


ind : Int -> String
ind i =
    "\n" ++ (List.repeat ((i + 1) * 2) " " |> String.join "")


prependAll : String -> String -> String
prependAll with target =
    String.lines target
        |> map
            (\line ->
                if String.trim line == "" then
                    line
                else
                    with ++ line
            )
        |> String.join "\n"


indAll : Int -> String -> String
indAll i s =
    "\n" ++ prependAll (String.dropLeft 1 (ind i)) s


uncons : List a -> ( Maybe a, List a )
uncons list =
    case list of
        a :: b ->
            ( Just a, b )

        [] ->
            ( Nothing, [] )


lastAndRest : List a -> ( Maybe a, List a )
lastAndRest list =
    list
        |> List.reverse
        |> uncons
        |> Tuple.mapSecond List.reverse


unquoteSplicing : String -> String
unquoteSplicing =
    Regex.replace All (regex "(^\\{|\\}$)") (\_ -> "")


operators : Dict String String
operators =
    [ ( "||", "||" )
    , ( "&&", "&&" )
    , ( "==", "==" )
    , ( "/=", "!=" )
    , ( "<", "<" )
    , ( ">", ">" )
    , ( ">=", ">=" )
    , ( "<=", "<=" )
    , ( "++", "++" )
    , ( "+", "+" )
    , ( "-", "-" )
    , ( "*", "*" )
    , ( "/", "/" )
    , ( ">>", ">>>" )
    , ( "<|", "" )
    , ( "<<", "" )
    , ( "|>", "|>" )

    -- Exception
    , ( "%", "rem" )

    -- Exception
    , ( "//", "" )

    -- Exception
    , ( "rem", "" )

    -- Exception
    , ( "^", "" )

    -- Exception
    , ( "::", "cons" )
    , ( "not", "!" )
    , ( ",", "tuple2" )
    , ( ",,", "tuple3" )
    , ( ",,,", "tuple4" )
    , ( ",,,,", "tuple5" )
    , ( "as", "=" )
    ]
        |> List.foldl (uncurry Dict.insert) Dict.empty


type Operator
    = None
    | Builtin
    | Custom


isOperator : String -> Operator
isOperator name =
    let
        is_builtin =
            operators
                |> Dict.keys
                |> List.any ((==) name)

        is_custom =
            Regex.contains (regex "^[+\\-\\/*=.$<>:&|^?%#@~!]+$") name
    in
        case ( is_builtin, is_custom ) of
            ( True, _ ) ->
                Builtin

            ( False, True ) ->
                Custom

            _ ->
                None


translateOperator : String -> String
translateOperator op =
    case Dict.get op operators of
        Just "" ->
            Debug.crash
                (op
                    ++ " is not a valid or not implemented yet operator"
                )

        Just key ->
            key

        _ ->
            ExReserved.replaceOp op


trimIndentations : String -> String
trimIndentations line =
    Regex.replace All (regex "\\s+\\n") (always "\n") line


generateArguments : Int -> List String
generateArguments =
    generateArguments_ "x"


generateArguments_ : String -> Int -> List String
generateArguments_ str n =
    List.range 1 n
        |> map toString
        |> map ((++) str)


unescape : String -> String
unescape s =
    Regex.replace All (regex "\\\\\\\\") (always "\\") s


escape : String -> String
escape s =
    Regex.replace All (regex "\\\\") (always "\\\\") s


modulePath : List String -> String
modulePath list =
    list
        |> map
            (\a ->
                if isUpper a then
                    a
                else
                    toSnakeCase True a
            )
        |> map maybeReplaceStd
        |> String.join "."


isStdModule : String -> Bool
isStdModule a =
    List.member a
        [ "Basics"
        , "List"
        , "String"
        , "Maybe"
        , "Char"
        , "Result"
        , "Tuple"
        ]


maybeReplaceStd : String -> String
maybeReplaceStd s =
    if isStdModule s then
        "X" ++ s
    else
        s


maybeOr : Maybe a -> Maybe a -> Maybe a
maybeOr m1 m2 =
    case m1 of
        Just a ->
            m1

        Nothing ->
            m2
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.3/example/Main.elm
module Main exposing (main)

import Ast
import Ast.Expression exposing (..)
import Ast.Statement exposing (..)
import Html exposing (..)
import Html
import Html.Events exposing (..)
import Json.Decode as JD


type Msg
    = Replace String


init : String
init =
    """module Main exposing (..)

f : Int -> Int
f x = x + 1

g : Int -> Int
g x = x * 2

h = f << g
"""


update : Msg -> String -> String
update action model =
    case action of
        Replace m ->
            m


withChild : a -> List (Html Msg) -> Html Msg
withChild title children =
    li []
        [ pre [] [ text <| toString title ]
        , ul [] children
        ]


expression : Expression -> Html Msg
expression e =
    case e of
        List es ->
            withChild e (List.map expression es)

        Application e1 e2 ->
            withChild e
                [ expression e1
                , expression e2
                ]

        e ->
            li [] [ pre [] [ text <| toString e ] ]


statement : Statement -> Html Msg
statement s =
    case s of
        FunctionDeclaration _ _ e ->
            withChild s [ expression e ]

        s ->
            li [] [ pre [] [ text <| toString s ] ]


tree : String -> Html Msg
tree m =
    case Ast.parse m of
        Ok ( _, _, statements ) ->
            ul [] (List.map statement statements)

        err ->
            div [] [ text <| toString err ]


view : String -> Html Msg
view model =
    div []
        [ textarea [ on "input" (JD.map Replace targetValue) ] [ text model ]
        , tree model
        ]


main : Program Never String Msg
main =
    Html.beginnerProgram
        { model = init
        , update = update
        , view = view
        }
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.3/src/Ast/BinOp.elm
module Ast.BinOp
    exposing
        ( Assoc(..)
        , OpTable
        , operators
        )

{-| This module exposes functions and types for working with operator
precedence tables.


# Types

@docs Assoc, OpTable


# Misc

@docs operators

-}

import Dict exposing (Dict)
import Ast.Helpers exposing (Name)


{-| FIXME
-}
type Assoc
    = N
    | L
    | R


{-| FIXME
-}
type alias OpTable =
    Dict Name ( Assoc, Int )


{-| The default operator precedence table.
-}
operators : OpTable
operators =
    Dict.empty
        |> Dict.insert "||" ( L, 2 )
        |> Dict.insert "&&" ( L, 3 )
        |> Dict.insert "==" ( L, 4 )
        |> Dict.insert "/=" ( L, 4 )
        |> Dict.insert "<" ( L, 4 )
        |> Dict.insert ">" ( L, 4 )
        |> Dict.insert ">=" ( L, 4 )
        |> Dict.insert "<=" ( L, 4 )
        |> Dict.insert "++" ( L, 5 )
        |> Dict.insert "::" ( R, 5 )
        |> Dict.insert "+" ( L, 6 )
        |> Dict.insert "-" ( L, 6 )
        |> Dict.insert "*" ( L, 7 )
        |> Dict.insert "/" ( L, 7 )
        |> Dict.insert "%" ( L, 7 )
        |> Dict.insert "//" ( L, 7 )
        |> Dict.insert "rem" ( L, 7 )
        |> Dict.insert "^" ( L, 8 )
        |> Dict.insert "<<" ( L, 9 )
        |> Dict.insert ">>" ( L, 9 )
        |> Dict.insert "<|" ( R, 1 )
        |> Dict.insert "|>" ( R, 1 )
        |> Dict.insert "=" ( R, 0 )



-- |> Dict.insert ","   (L, 0)
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.3/src/Ast/Expression.elm
module Ast.Expression
    exposing
        ( Expression(..)
        , expression
        , term
        )

{-| This module exposes parsers for Elm expressions.


# Types

@docs Expression


# Parsers

@docs expression


# Expression

@docs term

-}

import Combine exposing (..)
import Combine.Char exposing (..)
import Combine.Num
import Dict exposing (Dict)
import List.Extra exposing (break, singleton)
import String
import Ast.BinOp exposing (..)
import Ast.Helpers exposing (..)


type Collect a
    = Cont a
    | Stop a


{-| Representations for Elm's expressions.
-}
type Expression
    = Character Char
    | String String
    | Integer Int
    | Float Float
    | Variable (List Name)
    | List (List Expression)
    | Tuple (List Expression)
    | Access Expression (List Name)
    | AccessFunction Name
    | Record (List ( Name, Expression ))
    | RecordUpdate Name (List ( Name, Expression ))
    | If Expression Expression Expression
    | Let (List ( Expression, Expression )) Expression
    | Case Expression (List ( Expression, Expression ))
    | Lambda (List Expression) Expression
    | Application Expression Expression
    | BinOp Expression Expression Expression


character : Parser s Expression
character =
    Character
        <$> between_ (Combine.string "'")
                (((Combine.string "\\" *> regex "(n|t|r|\\\\|x..)")
                    >>= (\a ->
                            case a of
                                "n" ->
                                    succeed '\n'

                                "t" ->
                                    succeed '\t'

                                "r" ->
                                    succeed '\x0D'

                                "\\" ->
                                    succeed '\\'

                                "0" ->
                                    succeed '\x00'

                                "x00" ->
                                    succeed '\x00'

                                a ->
                                    fail ("No such character as \\" ++ a)
                        )
                 )
                    <|> anyChar
                )


string : Parser s Expression
string =
    let
        singleString =
            String
                <$> (Combine.string "\"" *> regex "(\\\\\\\\|\\\\\"|[^\"\n])*" <* Combine.string "\"")

        multiString =
            (String << String.concat)
                <$> (Combine.string "\"\"\"" *> many (regex "[^\"]*") <* Combine.string "\"\"\"")
    in
        multiString <|> singleString


integer : Parser s Expression
integer =
    Integer <$> Combine.Num.int


float : Parser s Expression
float =
    Float <$> Combine.Num.float


access : Parser s Expression
access =
    Access <$> variable <*> many1 (Combine.string "." *> loName)


accessFunction : Parser s Expression
accessFunction =
    AccessFunction <$> (Combine.string "." *> loName)


variable : Parser s Expression
variable =
    Variable
        <$> choice
                [ singleton <$> emptyTuple
                , singleton <$> loName
                , sepBy1 (Combine.string ".") upName
                , singleton <$> parens operator
                , singleton <$> parens (Combine.regex ",+")
                ]


list : OpTable -> Parser s Expression
list ops =
    lazy <|
        \() ->
            List <$> brackets (commaSeparated_ (expression ops))


tuple : OpTable -> Parser s Expression
tuple ops =
    lazy <|
        \() ->
            Tuple
                <$> (parens (commaSeparated_ (expression ops))
                        >>= \a ->
                                case a of
                                    [ _ ] ->
                                        fail "No single tuples"

                                    anyOther ->
                                        succeed anyOther
                    )


record : OpTable -> Parser s Expression
record ops =
    lazy <|
        \() ->
            Record <$> braces (commaSeparated ((,) <$> loName <*> (symbol "=" *> expression ops)))


simplifiedRecord : Parser s Expression
simplifiedRecord =
    lazy <|
        \() ->
            Record <$> (braces (commaSeparated ((\a -> ( a, Variable [ a ] )) <$> loName)))


recordUpdate : OpTable -> Parser s Expression
recordUpdate ops =
    lazy <|
        \() ->
            RecordUpdate
                <$> (symbol "{" *> loName)
                <*> (symbol "|"
                        *> (commaSeparated ((,) <$> loName <*> (symbol "=" *> expression ops)))
                        <* symbol "}"
                    )


letExpression : OpTable -> Parser s Expression
letExpression ops =
    lazy <|
        \() ->
            Let
                <$> (symbol "let" *> many1 (letBinding ops))
                <*> (symbol "in" *> expression ops)


letBinding : OpTable -> Parser s ( Expression, Expression )
letBinding ops =
    lazy <|
        \() ->
            (,)
                <$> (between_ whitespace (expression ops))
                <*> (symbol "=" *> expression ops)


ifExpression : OpTable -> Parser s Expression
ifExpression ops =
    lazy <|
        \() ->
            If
                <$> (symbol "if" *> expression ops)
                <*> (symbol "then" *> expression ops)
                <*> (symbol "else" *> expression ops)


caseExpression : OpTable -> Parser s Expression
caseExpression ops =
    lazy <|
        \() ->
            Case
                <$> (symbol "case" *> expression ops)
                <*> (symbol "of" *> many1 (caseBinding ops))


caseBinding : OpTable -> Parser s ( Expression, Expression )
caseBinding ops =
    lazy <|
        \() ->
            (,)
                <$> (whitespace *> expression ops)
                <*> (symbol "->" *> expression ops)


lambda : OpTable -> Parser s Expression
lambda ops =
    lazy <|
        \() ->
            Lambda
                <$> (symbol "\\" *> many (between_ spaces (term ops)))
                <*> (symbol "->" *> expression ops)


application : OpTable -> Parser s Expression
application ops =
    lazy <|
        \() ->
            term ops |> chainl (Application <$ spacesOrIndentedNewline ops)


spacesOrIndentedNewline : OpTable -> Parser s String
spacesOrIndentedNewline ops =
    let
        startsBinding =
            or
                (letBinding ops)
                (caseBinding ops)

        failAtBinding =
            maybe startsBinding
                |> andThen
                    (\x ->
                        case x of
                            Just _ ->
                                fail "next line starts a new case or let binding"

                            Nothing ->
                                succeed ""
                    )
    in
        or
            (spaces *> newline *> spaces_ *> lookAhead failAtBinding)
            (spaces_)


binary : OpTable -> Parser s Expression
binary ops =
    lazy <|
        \() ->
            let
                next =
                    between_ whitespace (choice [ operator, symbol "as" ])
                        |> andThen
                            (\op ->
                                choice [ Cont <$> application ops, Stop <$> expression ops ]
                                    |> andThen
                                        (\e ->
                                            case e of
                                                Cont t ->
                                                    ((::) ( op, t )) <$> collect

                                                Stop e ->
                                                    succeed [ ( op, e ) ]
                                        )
                            )

                collect =
                    next <|> succeed []
            in
                application ops
                    |> andThen
                        (\e ->
                            collect
                                |> andThen
                                    (\eops ->
                                        split ops 0 e eops
                                    )
                        )


{-| A parses for term
-}
term : OpTable -> Parser s Expression
term ops =
    lazy <|
        \() ->
            choice
                [ character
                , string
                , float
                , integer
                , access
                , accessFunction
                , variable
                , list ops
                , tuple ops
                , recordUpdate ops
                , record ops
                , simplifiedRecord
                , parens (between_ whitespace (expression ops))
                ]


{-| A parser for Elm expressions.
-}
expression : OpTable -> Parser s Expression
expression ops =
    lazy <|
        \() ->
            choice
                [ letExpression ops
                , caseExpression ops
                , ifExpression ops
                , lambda ops
                , binary ops
                ]


op : OpTable -> String -> ( Assoc, Int )
op ops n =
    Dict.get n ops
        |> Maybe.withDefault ( L, 9 )


assoc : OpTable -> String -> Assoc
assoc ops n =
    Tuple.first <| op ops n


level : OpTable -> String -> Int
level ops n =
    Tuple.second <| op ops n


hasLevel : OpTable -> Int -> ( String, Expression ) -> Bool
hasLevel ops l ( n, _ ) =
    level ops n == l


split : OpTable -> Int -> Expression -> List ( String, Expression ) -> Parser s Expression
split ops l e eops =
    case eops of
        [] ->
            succeed e

        _ ->
            findAssoc ops l eops
                |> andThen
                    (\assoc ->
                        sequence (splitLevel ops l e eops)
                            |> andThen
                                (\es ->
                                    let
                                        ops_ =
                                            List.filterMap
                                                (\x ->
                                                    if hasLevel ops l x then
                                                        Just (Tuple.first x)
                                                    else
                                                        Nothing
                                                )
                                                eops
                                    in
                                        case assoc of
                                            R ->
                                                joinR es ops_

                                            _ ->
                                                joinL es ops_
                                )
                    )


splitLevel : OpTable -> Int -> Expression -> List ( String, Expression ) -> List (Parser s Expression)
splitLevel ops l e eops =
    case break (hasLevel ops l) eops of
        ( lops, ( _, e_ ) :: rops ) ->
            split ops (l + 1) e lops :: splitLevel ops l e_ rops

        ( lops, [] ) ->
            [ split ops (l + 1) e lops ]


joinL : List Expression -> List String -> Parser s Expression
joinL es ops =
    case ( es, ops ) of
        ( [ e ], [] ) ->
            succeed e

        ( a :: b :: remE, op :: remO ) ->
            joinL ((BinOp (Variable [ op ]) a b) :: remE) remO

        _ ->
            fail ""


joinR : List Expression -> List String -> Parser s Expression
joinR es ops =
    case ( es, ops ) of
        ( [ e ], [] ) ->
            succeed e

        ( a :: b :: remE, op :: remO ) ->
            joinR (b :: remE) remO
                |> andThen
                    (\e ->
                        succeed (BinOp (Variable [ op ]) a e)
                    )

        _ ->
            fail ""


findAssoc : OpTable -> Int -> List ( String, Expression ) -> Parser s Assoc
findAssoc ops l eops =
    let
        lops =
            List.filter (hasLevel ops l) eops

        assocs =
            List.map (assoc ops << Tuple.first) lops

        error issue =
            let
                operators =
                    List.map Tuple.first lops |> String.join " and "
            in
                "conflicting " ++ issue ++ " for operators " ++ operators
    in
        if List.all ((==) L) assocs then
            succeed L
        else if List.all ((==) R) assocs then
            succeed R
        else if List.all ((==) N) assocs then
            case assocs of
                [ _ ] ->
                    succeed N

                _ ->
                    fail <| error "precedence"
        else
            fail <| error "associativity"
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.3/src/Ast/Helpers.elm
module Ast.Helpers exposing (..)

import Combine exposing (..)
import Combine.Char exposing (..)
import String


type alias Name =
    String


type alias QualifiedType =
    List Name


type alias ModuleName =
    List String


type alias Alias =
    String


reserved : List Name
reserved =
    [ "module"
    , "where"
    , "import"
    , "as"
    , "exposing"
    , "type"
    , "alias"
    , "port"
    , "if"
    , "then"
    , "else"
    , "let"
    , "in"
    , "case"
    , "of"
    ]


reservedOperators : List Name
reservedOperators =
    [ "=", ".", "..", "->", "--", "|", ":" ]


between_ : Parser s a -> Parser s res -> Parser s res
between_ p =
    between p p


spaces : Parser s String
spaces =
    regex "[ \t]*"


spaces_ : Parser s String
spaces_ =
    regex "[ \t]+"


symbol : String -> Parser s String
symbol k =
    between_ whitespace (string k)


initialSymbol : String -> Parser s String
initialSymbol k =
    string k <* spaces


commaSeparated : Parser s res -> Parser s (List res)
commaSeparated p =
    sepBy1 (string ",") (between_ whitespace p)


commaSeparated_ : Parser s res -> Parser s (List res)
commaSeparated_ p =
    sepBy (string ",") (between_ whitespace p)


name : Parser s Char -> Parser s String
name p =
    String.cons <$> p <*> regex "[a-zA-Z0-9-_]*"


loName : Parser s String
loName =
    let
        loName_ =
            name lower
                |> andThen
                    (\n ->
                        if List.member n reserved then
                            fail <| "name '" ++ n ++ "' is reserved"
                        else
                            succeed n
                    )
    in
        string "_" <|> loName_


upName : Parser s String
upName =
    name upper


emptyTuple : Parser s String
emptyTuple =
    string "()"


operator : Parser s String
operator =
    regex "[+\\-\\/*=.$<>:&|^?%#@~!]+|\x08as\x08"
        |> andThen
            (\n ->
                if List.member n reservedOperators then
                    fail <| "operator '" ++ n ++ "' is reserved"
                else
                    succeed n
            )


functionName : Parser s String
functionName =
    loName


moduleName : Parser s ModuleName
moduleName =
    between_ spaces <| sepBy1 (string ".") upName
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.3/src/Ast/Statement.elm
module Ast.Statement
    exposing
        ( ExportSet(..)
        , Type(..)
        , Statement(..)
        , statement
        , statements
        , infixStatements
        , opTable
        )

{-| This module exposes parsers for Elm statements.


# Types

@docs ExportSet, Type, Statement


# Parsers

@docs statement, statements, infixStatements, opTable

-}

import Combine exposing (..)
import Combine.Char exposing (..)
import Combine.Num
import Dict
import String
import Ast.BinOp exposing (Assoc(..), OpTable)
import Ast.Expression exposing (Expression, expression, term)
import Ast.Helpers exposing (..)


{-| Representations for modules' exports.
-}
type ExportSet
    = AllExport
    | SubsetExport (List ExportSet)
    | FunctionExport Name
    | TypeExport Name (Maybe ExportSet)


{-| Representations for Elm's type syntax.
-}
type Type
    = TypeConstructor QualifiedType (List Type)
    | TypeVariable Name
    | TypeRecordConstructor Type (List ( Name, Type ))
    | TypeRecord (List ( Name, Type ))
    | TypeTuple (List Type)
    | TypeApplication Type Type


{-| Representations for Elm's statements.
-}
type Statement
    = ModuleDeclaration ModuleName ExportSet
    | PortModuleDeclaration ModuleName ExportSet
    | EffectModuleDeclaration ModuleName (List ( Name, Name )) ExportSet
    | ImportStatement ModuleName (Maybe Alias) (Maybe ExportSet)
    | TypeAliasDeclaration Type Type
    | TypeDeclaration Type (List Type)
    | PortTypeDeclaration Name Type
    | PortDeclaration Name (List Name) Expression
    | FunctionTypeDeclaration Name Type
    | FunctionDeclaration Name (List Expression) Expression
    | InfixDeclaration Assoc Int Name
    | Comment String



-- Exports
-- -------


allExport : Parser s ExportSet
allExport =
    AllExport <$ symbol ".."


functionExport : Parser s ExportSet
functionExport =
    FunctionExport <$> choice [ functionName, parens operator ]


constructorSubsetExports : Parser s ExportSet
constructorSubsetExports =
    SubsetExport <$> commaSeparated (FunctionExport <$> upName)


constructorExports : Parser s (Maybe ExportSet)
constructorExports =
    maybe <|
        parens <|
            choice
                [ allExport
                , constructorSubsetExports
                ]


typeExport : Parser s ExportSet
typeExport =
    TypeExport <$> (upName <* spaces) <*> constructorExports


subsetExport : Parser s ExportSet
subsetExport =
    SubsetExport
        <$> commaSeparated (functionExport |> or typeExport)


exports : Parser s ExportSet
exports =
    parens <| choice [ allExport, subsetExport ]



-- Types
-- -----


typeVariable : Parser s Type
typeVariable =
    TypeVariable <$> regex "[a-z]+(\\w|_)*"


typeConstant : Parser s Type
typeConstant =
    TypeConstructor <$> sepBy1 (string ".") upName <*> succeed []


typeApplication : Parser s (Type -> Type -> Type)
typeApplication =
    TypeApplication <$ symbol "->"


typeTuple : Parser s Type
typeTuple =
    lazy <|
        \() ->
            TypeTuple <$> parens (commaSeparated_ type_)


typeRecordPair : Parser s ( Name, Type )
typeRecordPair =
    lazy <|
        \() ->
            (,) <$> (loName <* symbol ":") <*> typeAnnotation


typeRecordPairs : Parser s (List ( Name, Type ))
typeRecordPairs =
    lazy <|
        \() ->
            commaSeparated_ typeRecordPair


typeRecordConstructor : Parser s Type
typeRecordConstructor =
    lazy <|
        \() ->
            braces <|
                TypeRecordConstructor
                    <$> (between_ spaces typeVariable)
                    <*> (symbol "|" *> typeRecordPairs)


typeRecord : Parser s Type
typeRecord =
    lazy <|
        \() ->
            braces <|
                TypeRecord
                    <$> typeRecordPairs


typeParameter : Parser s Type
typeParameter =
    lazy <|
        \() ->
            between_ (or (spaces *> newline *> spaces_) spaces) <|
                choice
                    [ typeVariable
                    , typeConstant
                    , typeRecordConstructor
                    , typeRecord
                    , typeTuple
                    , parens typeAnnotation
                    ]


typeConstructor : Parser s Type
typeConstructor =
    lazy <|
        \() ->
            TypeConstructor <$> sepBy1 (string ".") upName <*> many typeParameter


type_ : Parser s Type
type_ =
    lazy <|
        \() ->
            between_ spaces <|
                choice
                    [ typeConstructor
                    , typeVariable
                    , typeRecordConstructor
                    , typeRecord
                    , typeTuple
                    , parens typeAnnotation
                    ]


typeAnnotation : Parser s Type
typeAnnotation =
    lazy <|
        \() ->
            type_ |> chainr typeApplication



-- Modules
-- -------


portModuleDeclaration : Parser s Statement
portModuleDeclaration =
    PortModuleDeclaration
        <$> (initialSymbol "port" *> symbol "module" *> moduleName)
        <*> (symbol "exposing" *> exports)


effectModuleDeclaration : Parser s Statement
effectModuleDeclaration =
    EffectModuleDeclaration
        <$> (initialSymbol "effect" *> symbol "module" *> moduleName)
        <*> (symbol "where" *> braces (commaSeparated ((,) <$> loName <*> (symbol "=" *> upName))))
        <*> (symbol "exposing" *> exports)


moduleDeclaration : Parser s Statement
moduleDeclaration =
    ModuleDeclaration
        <$> (initialSymbol "module" *> moduleName)
        <*> (symbol "exposing" *> exports)



-- Imports
-- -------


importStatement : Parser s Statement
importStatement =
    ImportStatement
        <$> (initialSymbol "import" *> moduleName)
        <*> maybe (symbol "as" *> upName)
        <*> maybe (symbol "exposing" *> exports)



-- Type declarations
-- -----------------


typeAliasDeclaration : Parser s Statement
typeAliasDeclaration =
    TypeAliasDeclaration
        <$> (initialSymbol "type" *> symbol "alias" *> type_)
        <*> (whitespace *> symbol "=" *> typeAnnotation)


typeDeclaration : Parser s Statement
typeDeclaration =
    TypeDeclaration
        <$> (initialSymbol "type" *> type_)
        <*> (whitespace *> symbol "=" *> (sepBy1 (symbol "|") (between_ whitespace typeConstructor)))



-- Ports
-- -----


portTypeDeclaration : Parser s Statement
portTypeDeclaration =
    PortTypeDeclaration
        <$> (initialSymbol "port" *> loName)
        <*> (symbol ":" *> typeAnnotation)


portDeclaration : OpTable -> Parser s Statement
portDeclaration ops =
    PortDeclaration
        <$> (initialSymbol "port" *> loName)
        <*> (many <| between_ spaces loName)
        <*> (symbol "=" *> expression ops)



-- Functions
-- ---------


functionTypeDeclaration : Parser s Statement
functionTypeDeclaration =
    FunctionTypeDeclaration <$> (choice [ loName, parens operator ] <* symbol ":") <*> typeAnnotation


functionDeclaration : OpTable -> Parser s Statement
functionDeclaration ops =
    FunctionDeclaration
        <$> (choice [ loName, parens operator ])
        <*> (many (between_ whitespace <| term ops))
        <*> (symbol "=" *> whitespace *> expression ops)



-- Infix declarations
-- ------------------


infixDeclaration : Parser s Statement
infixDeclaration =
    InfixDeclaration
        <$> choice
                [ L <$ initialSymbol "infixl"
                , R <$ initialSymbol "infixr"
                , N <$ initialSymbol "infix"
                ]
        <*> (spaces *> Combine.Num.int)
        <*> (spaces *> (loName <|> operator))



-- Comments
-- --------


singleLineComment : Parser s Statement
singleLineComment =
    Comment <$> (string "--" *> regex ".*" <* whitespace)


multiLineComment : Parser s Statement
multiLineComment =
    (Comment << String.fromList) <$> (string "{-" *> manyTill anyChar (string "-}"))


comment : Parser s Statement
comment =
    singleLineComment <|> multiLineComment


{-| A parser for stand-alone Elm statements.
-}
statement : OpTable -> Parser s Statement
statement ops =
    choice
        [ portModuleDeclaration
        , effectModuleDeclaration
        , moduleDeclaration
        , importStatement
        , typeAliasDeclaration
        , typeDeclaration
        , portTypeDeclaration
        , portDeclaration ops
        , functionTypeDeclaration
        , functionDeclaration ops
        , infixDeclaration
        , comment
        ]


{-| A parser for a series of Elm statements.
-}
statements : OpTable -> Parser s (List Statement)
statements ops =
    manyTill (whitespace *> statement ops <* whitespace) end


{-| A scanner for infix statements. This is useful for performing a
first pass over a module to find all of the infix declarations in it.
-}
infixStatements : Parser s (List Statement)
infixStatements =
    let
        statements =
            many
                (choice
                    [ Just <$> infixDeclaration
                    , Nothing <$ regex ".*"
                    ]
                    <* whitespace
                )
                <* end
    in
        statements
            |> andThen
                (\xs ->
                    succeed <| List.filterMap identity xs
                )


{-| A scanner that returns an updated OpTable based on the infix
declarations in the input.
-}
opTable : OpTable -> Parser s OpTable
opTable ops =
    let
        collect s d =
            case s of
                InfixDeclaration a l n ->
                    Dict.insert n ( a, l ) d

                _ ->
                    Debug.crash "impossible"
    in
        infixStatements
            |> andThen
                (\xs ->
                    succeed <| List.foldr collect ops xs
                )
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.3/src/Ast.elm
module Ast
    exposing
        ( parseExpression
        , parseStatement
        , parseOpTable
        , parseModule
        , parse
        )

{-| This module exposes functions for parsing Elm code.


# Parsers

@docs parseExpression, parseStatement, parseOpTable, parseModule, parse

-}

import Combine exposing (end, (<*))
import Ast.BinOp exposing (OpTable, operators)
import Ast.Expression exposing (Expression, expression)
import Ast.Statement exposing (Statement, statement, statements, opTable)


{-| Parse an Elm expression.
-}
parseExpression : OpTable -> String -> Result (Combine.ParseErr ()) (Combine.ParseOk () Expression)
parseExpression ops =
    Combine.parse (expression ops <* end)


{-| Parse an Elm statement.
-}
parseStatement : OpTable -> String -> Result (Combine.ParseErr ()) (Combine.ParseOk () Statement)
parseStatement ops =
    Combine.parse (statement ops <* end)


{-| Parse an OpTable from a module.
-}
parseOpTable : OpTable -> String -> Result (Combine.ParseErr ()) (Combine.ParseOk () OpTable)
parseOpTable ops =
    Combine.parse (opTable ops)


{-| Parse an Elm module.
-}
parseModule : OpTable -> String -> Result (Combine.ParseErr ()) (Combine.ParseOk () (List Statement))
parseModule ops =
    Combine.parse (statements ops)


{-| Parse an Elm module, scanning for infix declarations first.
-}
parse : String -> Result (Combine.ParseErr ()) (Combine.ParseOk () (List Statement))
parse input =
    case parseOpTable operators input of
        Ok ( state, stream, ops ) ->
            parseModule ops input

        Err e ->
            (Err e)
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.6/example/Main.elm
module Main exposing (main)

import Ast
import Ast.Expression exposing (..)
import Ast.Statement exposing (..)
import Html exposing (..)
import Html
import Html.Events exposing (..)
import Json.Decode as JD


type Msg
    = Replace String


init : String
init =
    """module Main exposing (..)

f : Int -> Int
f x = x + 1

g : Int -> Int
g x = x * 2

h = f << g
"""


update : Msg -> String -> String
update action model =
    case action of
        Replace m ->
            m


withChild : a -> List (Html Msg) -> Html Msg
withChild title children =
    li []
        [ pre [] [ text <| toString title ]
        , ul [] children
        ]


expression : Expression -> Html Msg
expression e =
    case e of
        List es ->
            withChild e (List.map expression es)

        Application e1 e2 ->
            withChild e
                [ expression e1
                , expression e2
                ]

        e ->
            li [] [ pre [] [ text <| toString e ] ]


statement : Statement -> Html Msg
statement s =
    case s of
        FunctionDeclaration _ _ e ->
            withChild s [ expression e ]

        s ->
            li [] [ pre [] [ text <| toString s ] ]


tree : String -> Html Msg
tree m =
    case Ast.parse m of
        Ok ( _, _, statements ) ->
            ul [] (List.map statement statements)

        err ->
            div [] [ text <| toString err ]


view : String -> Html Msg
view model =
    div []
        [ textarea [ on "input" (JD.map Replace targetValue) ] [ text model ]
        , tree model
        ]


main : Program Never String Msg
main =
    Html.beginnerProgram
        { model = init
        , update = update
        , view = view
        }
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.6/src/Ast/BinOp.elm
module Ast.BinOp
    exposing
        ( Assoc(..)
        , OpTable
        , operators
        )

{-| This module exposes functions and types for working with operator
precedence tables.


# Types

@docs Assoc, OpTable


# Misc

@docs operators

-}

import Dict exposing (Dict)
import Ast.Helpers exposing (Name)


{-| FIXME
-}
type Assoc
    = N
    | L
    | R


{-| FIXME
-}
type alias OpTable =
    Dict Name ( Assoc, Int )


{-| The default operator precedence table.
-}
operators : OpTable
operators =
    Dict.empty
        |> Dict.insert "||" ( L, 2 )
        |> Dict.insert "&&" ( L, 3 )
        |> Dict.insert "==" ( L, 4 )
        |> Dict.insert "/=" ( L, 4 )
        |> Dict.insert "<" ( L, 4 )
        |> Dict.insert ">" ( L, 4 )
        |> Dict.insert ">=" ( L, 4 )
        |> Dict.insert "<=" ( L, 4 )
        |> Dict.insert "++" ( L, 5 )
        |> Dict.insert "::" ( R, 5 )
        |> Dict.insert "+" ( L, 6 )
        |> Dict.insert "-" ( L, 6 )
        |> Dict.insert "*" ( L, 7 )
        |> Dict.insert "/" ( L, 7 )
        |> Dict.insert "%" ( L, 7 )
        |> Dict.insert "//" ( L, 7 )
        |> Dict.insert "rem" ( L, 7 )
        |> Dict.insert "^" ( L, 8 )
        |> Dict.insert "<<" ( L, 9 )
        |> Dict.insert ">>" ( L, 9 )
        |> Dict.insert "<|" ( R, 1 )
        |> Dict.insert "|>" ( R, 1 )
        |> Dict.insert "=" ( R, 0 )



-- |> Dict.insert ","   (L, 0)
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.6/src/Ast/Expression.elm
module Ast.Expression
    exposing
        ( Expression(..)
        , expression
        , term
        )

{-| This module exposes parsers for Elm expressions.


# Types

@docs Expression


# Parsers

@docs expression


# Expression

@docs term

-}

import Combine exposing (..)
import Combine.Char exposing (..)
import Combine.Num
import Dict exposing (Dict)
import List.Extra exposing (break, singleton)
import String
import Ast.BinOp exposing (..)
import Ast.Helpers exposing (..)
import Hex
import Char


type Collect a
    = Cont a
    | Stop a


{-| Representations for Elm's expressions.
-}
type Expression
    = Character Char
    | String String
    | Integer Int
    | Float Float
    | Variable (List Name)
    | List (List Expression)
    | Tuple (List Expression)
    | Access Expression (List Name)
    | AccessFunction Name
    | Record (List ( Name, Expression ))
    | RecordUpdate Name (List ( Name, Expression ))
    | If Expression Expression Expression
    | Let (List ( Expression, Expression )) Expression
    | Case Expression (List ( Expression, Expression ))
    | Lambda (List Expression) Expression
    | Application Expression Expression
    | BinOp Expression Expression Expression


character : Parser s Expression
character =
    Character
        <$> between_ (Combine.string "'")
                (((Combine.string "\\" *> regex "(n|t|r|\\\\|x..)")
                    >>= (\a ->
                            case String.uncons a of
                                Just ( 'n', "" ) ->
                                    succeed '\n'

                                Just ( 't', "" ) ->
                                    succeed '\t'

                                Just ( 'r', "" ) ->
                                    succeed '\x0D'

                                Just ( '\\', "" ) ->
                                    succeed '\\'

                                Just ( '0', "" ) ->
                                    succeed '\x00'

                                Just ( 'x', hex ) ->
                                    hex
                                        |> String.toLower
                                        |> Hex.fromString
                                        |> Result.map Char.fromCode
                                        |> Result.map succeed
                                        |> Result.withDefault (fail "Invalid charcode")

                                Just other ->
                                    fail ("No such character as \\" ++ toString other)

                                Nothing ->
                                    fail "No character"
                        )
                 )
                    <|> anyChar
                )


string : Parser s Expression
string =
    let
        singleString =
            String
                <$> (Combine.string "\"" *> regex "(\\\\\\\\|\\\\\"|[^\"\n])*" <* Combine.string "\"")

        multiString =
            (String << String.concat)
                <$> (Combine.string "\"\"\"" *> many (regex "[^\"]*") <* Combine.string "\"\"\"")
    in
        multiString <|> singleString


integer : Parser s Expression
integer =
    Integer <$> Combine.Num.int


float : Parser s Expression
float =
    Float <$> Combine.Num.float


access : Parser s Expression
access =
    Access <$> variable <*> many1 (Combine.string "." *> loName)


accessFunction : Parser s Expression
accessFunction =
    AccessFunction <$> (Combine.string "." *> loName)


variable : Parser s Expression
variable =
    Variable
        <$> choice
                [ singleton <$> emptyTuple
                , singleton <$> loName
                , sepBy1 (Combine.string ".") upName
                , singleton <$> parens operator
                , singleton <$> parens (Combine.regex ",+")
                ]


list : OpTable -> Parser s Expression
list ops =
    lazy <|
        \() ->
            List <$> brackets (commaSeparated_ (expression ops))


tuple : OpTable -> Parser s Expression
tuple ops =
    lazy <|
        \() ->
            Tuple
                <$> (parens (commaSeparated_ (expression ops))
                        >>= \a ->
                                case a of
                                    [ _ ] ->
                                        fail "No single tuples"

                                    anyOther ->
                                        succeed anyOther
                    )


record : OpTable -> Parser s Expression
record ops =
    lazy <|
        \() ->
            Record <$> braces (commaSeparated ((,) <$> loName <*> (symbol "=" *> expression ops)))


simplifiedRecord : Parser s Expression
simplifiedRecord =
    lazy <|
        \() ->
            Record <$> (braces (commaSeparated ((\a -> ( a, Variable [ a ] )) <$> loName)))


recordUpdate : OpTable -> Parser s Expression
recordUpdate ops =
    lazy <|
        \() ->
            RecordUpdate
                <$> (symbol "{" *> loName)
                <*> (symbol "|"
                        *> (commaSeparated ((,) <$> loName <*> (symbol "=" *> expression ops)))
                        <* symbol "}"
                    )


letExpression : OpTable -> Parser s Expression
letExpression ops =
    lazy <|
        \() ->
            Let
                <$> (symbol_ "let" *> many1 (letBinding ops))
                <*> (symbol "in" *> expression ops)


letBinding : OpTable -> Parser s ( Expression, Expression )
letBinding ops =
    lazy <|
        \() ->
            (,)
                <$> (between_ whitespace (expression ops))
                <*> (symbol "=" *> expression ops)


ifExpression : OpTable -> Parser s Expression
ifExpression ops =
    lazy <|
        \() ->
            If
                <$> (symbol "if" *> expression ops)
                <*> (symbol "then" *> expression ops)
                <*> (symbol "else" *> expression ops)


caseExpression : OpTable -> Parser s Expression
caseExpression ops =
    lazy <|
        \() ->
            Case
                <$> (symbol "case" *> expression ops)
                <*> (symbol "of" *> many1 (caseBinding ops))


caseBinding : OpTable -> Parser s ( Expression, Expression )
caseBinding ops =
    lazy <|
        \() ->
            (,)
                <$> (whitespace *> expression ops)
                <*> (symbol "->" *> expression ops)


lambda : OpTable -> Parser s Expression
lambda ops =
    lazy <|
        \() ->
            Lambda
                <$> (symbol "\\" *> many (between_ spaces (term ops)))
                <*> (symbol "->" *> expression ops)


application : OpTable -> Parser s Expression
application ops =
    lazy <|
        \() ->
            term ops |> chainl (Application <$ spacesOrIndentedNewline ops)


spacesOrIndentedNewline : OpTable -> Parser s String
spacesOrIndentedNewline ops =
    let
        startsBinding =
            or
                (letBinding ops)
                (caseBinding ops)

        failAtBinding =
            maybe startsBinding
                |> andThen
                    (\x ->
                        case x of
                            Just _ ->
                                fail "next line starts a new case or let binding"

                            Nothing ->
                                succeed ""
                    )
    in
        or
            (spaces *> newline *> spaces_ *> lookAhead failAtBinding)
            (spaces_)


binary : OpTable -> Parser s Expression
binary ops =
    lazy <|
        \() ->
            let
                next =
                    between_ whitespace (choice [ operator, symbol_ "as" ])
                        |> andThen
                            (\op ->
                                choice [ Cont <$> application ops, Stop <$> expression ops ]
                                    |> andThen
                                        (\e ->
                                            case e of
                                                Cont t ->
                                                    ((::) ( op, t )) <$> collect

                                                Stop e ->
                                                    succeed [ ( op, e ) ]
                                        )
                            )

                collect =
                    next <|> succeed []
            in
                application ops
                    |> andThen
                        (\e ->
                            collect
                                |> andThen
                                    (\eops ->
                                        split ops 0 e eops
                                    )
                        )


{-| A parses for term
-}
term : OpTable -> Parser s Expression
term ops =
    lazy <|
        \() ->
            choice
                [ character
                , string
                , float
                , integer
                , access
                , accessFunction
                , variable
                , list ops
                , tuple ops
                , recordUpdate ops
                , record ops
                , simplifiedRecord
                , parens (between_ whitespace (expression ops))
                ]


{-| A parser for Elm expressions.
-}
expression : OpTable -> Parser s Expression
expression ops =
    lazy <|
        \() ->
            choice
                [ letExpression ops
                , caseExpression ops
                , ifExpression ops
                , lambda ops
                , binary ops
                ]


op : OpTable -> String -> ( Assoc, Int )
op ops n =
    Dict.get n ops
        |> Maybe.withDefault ( L, 9 )


assoc : OpTable -> String -> Assoc
assoc ops n =
    Tuple.first <| op ops n


level : OpTable -> String -> Int
level ops n =
    Tuple.second <| op ops n


hasLevel : OpTable -> Int -> ( String, Expression ) -> Bool
hasLevel ops l ( n, _ ) =
    level ops n == l


split : OpTable -> Int -> Expression -> List ( String, Expression ) -> Parser s Expression
split ops l e eops =
    case eops of
        [] ->
            succeed e

        _ ->
            findAssoc ops l eops
                |> andThen
                    (\assoc ->
                        sequence (splitLevel ops l e eops)
                            |> andThen
                                (\es ->
                                    let
                                        ops_ =
                                            List.filterMap
                                                (\x ->
                                                    if hasLevel ops l x then
                                                        Just (Tuple.first x)
                                                    else
                                                        Nothing
                                                )
                                                eops
                                    in
                                        case assoc of
                                            R ->
                                                joinR es ops_

                                            _ ->
                                                joinL es ops_
                                )
                    )


splitLevel : OpTable -> Int -> Expression -> List ( String, Expression ) -> List (Parser s Expression)
splitLevel ops l e eops =
    case break (hasLevel ops l) eops of
        ( lops, ( _, e_ ) :: rops ) ->
            split ops (l + 1) e lops :: splitLevel ops l e_ rops

        ( lops, [] ) ->
            [ split ops (l + 1) e lops ]


joinL : List Expression -> List String -> Parser s Expression
joinL es ops =
    case ( es, ops ) of
        ( [ e ], [] ) ->
            succeed e

        ( a :: b :: remE, op :: remO ) ->
            joinL ((BinOp (Variable [ op ]) a b) :: remE) remO

        _ ->
            fail ""


joinR : List Expression -> List String -> Parser s Expression
joinR es ops =
    case ( es, ops ) of
        ( [ e ], [] ) ->
            succeed e

        ( a :: b :: remE, op :: remO ) ->
            joinR (b :: remE) remO
                |> andThen
                    (\e ->
                        succeed (BinOp (Variable [ op ]) a e)
                    )

        _ ->
            fail ""


findAssoc : OpTable -> Int -> List ( String, Expression ) -> Parser s Assoc
findAssoc ops l eops =
    let
        lops =
            List.filter (hasLevel ops l) eops

        assocs =
            List.map (assoc ops << Tuple.first) lops

        error issue =
            let
                operators =
                    List.map Tuple.first lops |> String.join " and "
            in
                "conflicting " ++ issue ++ " for operators " ++ operators
    in
        if List.all ((==) L) assocs then
            succeed L
        else if List.all ((==) R) assocs then
            succeed R
        else if List.all ((==) N) assocs then
            case assocs of
                [ _ ] ->
                    succeed N

                _ ->
                    fail <| error "precedence"
        else
            fail <| error "associativity"
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.6/src/Ast/Helpers.elm
module Ast.Helpers exposing (..)

import Combine exposing (..)
import Combine.Char exposing (..)
import String


type alias Name =
    String


type alias QualifiedType =
    List Name


type alias ModuleName =
    List String


type alias Alias =
    String


reserved : List Name
reserved =
    [ "module"
    , "where"
    , "import"
    , "as"
    , "exposing"
    , "type"
    , "alias"
    , "port"
    , "if"
    , "then"
    , "else"
    , "let"
    , "in"
    , "case"
    , "of"
    ]


reservedOperators : List Name
reservedOperators =
    [ "=", ".", "..", "->", "--", "|", ":" ]


between_ : Parser s a -> Parser s res -> Parser s res
between_ p =
    between p p


spaces : Parser s String
spaces =
    regex "[ \\t]*"


spaces_ : Parser s String
spaces_ =
    regex "[ \\t]+"


symbol_ : String -> Parser s String
symbol_ k =
    between_ whitespace (string k <* regex "( |\\n)+")


symbol : String -> Parser s String
symbol k =
    between_ whitespace (string k)


initialSymbol : String -> Parser s String
initialSymbol k =
    string k <* spaces_


commaSeparated : Parser s res -> Parser s (List res)
commaSeparated p =
    sepBy1 (string ",") (between_ whitespace p)


commaSeparated_ : Parser s res -> Parser s (List res)
commaSeparated_ p =
    sepBy (string ",") (between_ whitespace p)


name : Parser s Char -> Parser s String
name p =
    String.cons <$> p <*> regex "[a-zA-Z0-9-_]*"


loName : Parser s String
loName =
    let
        loName_ =
            name lower
                |> andThen
                    (\n ->
                        if List.member n reserved then
                            fail <| "name '" ++ n ++ "' is reserved"
                        else
                            succeed n
                    )
    in
        string "_" <|> loName_


upName : Parser s String
upName =
    name upper


emptyTuple : Parser s String
emptyTuple =
    string "()"


operator : Parser s String
operator =
    regex "[+\\-\\/*=.$<>:&|^?%#@~!]+|\x8As\x08"
        |> andThen
            (\n ->
                if List.member n reservedOperators then
                    fail <| "operator '" ++ n ++ "' is reserved"
                else
                    succeed n
            )


functionName : Parser s String
functionName =
    loName


moduleName : Parser s ModuleName
moduleName =
    between_ spaces <| sepBy1 (string ".") upName
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.6/src/Ast/Statement.elm
module Ast.Statement
    exposing
        ( ExportSet(..)
        , Type(..)
        , Statement(..)
        , statement
        , statements
        , infixStatements
        , opTable
        )

{-| This module exposes parsers for Elm statements.


# Types

@docs ExportSet, Type, Statement


# Parsers

@docs statement, statements, infixStatements, opTable

-}

import Combine exposing (..)
import Combine.Char exposing (..)
import Combine.Num
import Dict
import String
import Ast.BinOp exposing (Assoc(..), OpTable)
import Ast.Expression exposing (Expression, expression, term)
import Ast.Helpers exposing (..)


{-| Representations for modules' exports.
-}
type ExportSet
    = AllExport
    | SubsetExport (List ExportSet)
    | FunctionExport Name
    | TypeExport Name (Maybe ExportSet)


{-| Representations for Elm's type syntax.
-}
type Type
    = TypeConstructor QualifiedType (List Type)
    | TypeVariable Name
    | TypeRecordConstructor Type (List ( Name, Type ))
    | TypeRecord (List ( Name, Type ))
    | TypeTuple (List Type)
    | TypeApplication Type Type


{-| Representations for Elm's statements.
-}
type Statement
    = ModuleDeclaration ModuleName ExportSet
    | PortModuleDeclaration ModuleName ExportSet
    | EffectModuleDeclaration ModuleName (List ( Name, Name )) ExportSet
    | ImportStatement ModuleName (Maybe Alias) (Maybe ExportSet)
    | TypeAliasDeclaration Type Type
    | TypeDeclaration Type (List Type)
    | PortTypeDeclaration Name Type
    | PortDeclaration Name (List Name) Expression
    | FunctionTypeDeclaration Name Type
    | FunctionDeclaration Name (List Expression) Expression
    | InfixDeclaration Assoc Int Name
    | Comment String



-- Exports
-- -------


allExport : Parser s ExportSet
allExport =
    AllExport <$ symbol ".."


functionExport : Parser s ExportSet
functionExport =
    FunctionExport <$> choice [ functionName, parens operator ]


constructorSubsetExports : Parser s ExportSet
constructorSubsetExports =
    SubsetExport <$> commaSeparated (FunctionExport <$> upName)


constructorExports : Parser s (Maybe ExportSet)
constructorExports =
    maybe <|
        parens <|
            choice
                [ allExport
                , constructorSubsetExports
                ]


typeExport : Parser s ExportSet
typeExport =
    TypeExport <$> (upName <* spaces) <*> constructorExports


subsetExport : Parser s ExportSet
subsetExport =
    SubsetExport
        <$> commaSeparated (functionExport |> or typeExport)


exports : Parser s ExportSet
exports =
    parens <| choice [ allExport, subsetExport ]



-- Types
-- -----


typeVariable : Parser s Type
typeVariable =
    TypeVariable <$> regex "[a-z]+(\\w|_)*"


typeConstant : Parser s Type
typeConstant =
    TypeConstructor <$> sepBy1 (string ".") upName <*> succeed []


typeApplication : Parser s (Type -> Type -> Type)
typeApplication =
    TypeApplication <$ symbol "->"


typeTuple : Parser s Type
typeTuple =
    lazy <|
        \() ->
            TypeTuple <$> parens (commaSeparated_ type_)


typeRecordPair : Parser s ( Name, Type )
typeRecordPair =
    lazy <|
        \() ->
            (,) <$> (loName <* symbol ":") <*> typeAnnotation


typeRecordPairs : Parser s (List ( Name, Type ))
typeRecordPairs =
    lazy <|
        \() ->
            commaSeparated_ typeRecordPair


typeRecordConstructor : Parser s Type
typeRecordConstructor =
    lazy <|
        \() ->
            braces <|
                TypeRecordConstructor
                    <$> (between_ spaces typeVariable)
                    <*> (symbol "|" *> typeRecordPairs)


typeRecord : Parser s Type
typeRecord =
    lazy <|
        \() ->
            braces <|
                TypeRecord
                    <$> typeRecordPairs


typeParameter : Parser s Type
typeParameter =
    lazy <|
        \() ->
            between_ (or (spaces *> newline *> spaces_) spaces) <|
                choice
                    [ typeVariable
                    , typeConstant
                    , typeRecordConstructor
                    , typeRecord
                    , typeTuple
                    , parens typeAnnotation
                    ]


typeConstructor : Parser s Type
typeConstructor =
    lazy <|
        \() ->
            TypeConstructor <$> sepBy1 (string ".") upName <*> many typeParameter


type_ : Parser s Type
type_ =
    lazy <|
        \() ->
            between_ spaces <|
                choice
                    [ typeConstructor
                    , typeVariable
                    , typeRecordConstructor
                    , typeRecord
                    , typeTuple
                    , parens typeAnnotation
                    ]


typeAnnotation : Parser s Type
typeAnnotation =
    lazy <|
        \() ->
            type_ |> chainr typeApplication



-- Modules
-- -------


portModuleDeclaration : Parser s Statement
portModuleDeclaration =
    PortModuleDeclaration
        <$> (initialSymbol "port" *> symbol "module" *> moduleName)
        <*> (symbol "exposing" *> exports)


effectModuleDeclaration : Parser s Statement
effectModuleDeclaration =
    EffectModuleDeclaration
        <$> (initialSymbol "effect" *> symbol "module" *> moduleName)
        <*> (symbol "where" *> braces (commaSeparated ((,) <$> loName <*> (symbol "=" *> upName))))
        <*> (symbol "exposing" *> exports)


moduleDeclaration : Parser s Statement
moduleDeclaration =
    ModuleDeclaration
        <$> (initialSymbol "module" *> moduleName)
        <*> (symbol "exposing" *> exports)



-- Imports
-- -------


importStatement : Parser s Statement
importStatement =
    ImportStatement
        <$> (initialSymbol "import" *> moduleName)
        <*> maybe (symbol "as" *> upName)
        <*> maybe (symbol "exposing" *> exports)



-- Type declarations
-- -----------------


typeAliasDeclaration : Parser s Statement
typeAliasDeclaration =
    TypeAliasDeclaration
        <$> (initialSymbol "type" *> symbol "alias" *> type_)
        <*> (whitespace *> symbol "=" *> typeAnnotation)


typeDeclaration : Parser s Statement
typeDeclaration =
    TypeDeclaration
        <$> (initialSymbol "type" *> type_)
        <*> (whitespace *> symbol "=" *> (sepBy1 (symbol "|") (between_ whitespace typeConstructor)))



-- Ports
-- -----


portTypeDeclaration : Parser s Statement
portTypeDeclaration =
    PortTypeDeclaration
        <$> (initialSymbol "port" *> loName)
        <*> (symbol ":" *> typeAnnotation)


portDeclaration : OpTable -> Parser s Statement
portDeclaration ops =
    PortDeclaration
        <$> (initialSymbol "port" *> loName)
        <*> (many <| between_ spaces loName)
        <*> (symbol "=" *> expression ops)



-- Functions
-- ---------


functionTypeDeclaration : Parser s Statement
functionTypeDeclaration =
    FunctionTypeDeclaration <$> (choice [ loName, parens operator ] <* symbol ":") <*> typeAnnotation


functionDeclaration : OpTable -> Parser s Statement
functionDeclaration ops =
    FunctionDeclaration
        <$> (choice [ loName, parens operator ])
        <*> (many (between_ whitespace <| term ops))
        <*> (symbol "=" *> whitespace *> expression ops)



-- Infix declarations
-- ------------------


infixDeclaration : Parser s Statement
infixDeclaration =
    InfixDeclaration
        <$> choice
                [ L <$ initialSymbol "infixl"
                , R <$ initialSymbol "infixr"
                , N <$ initialSymbol "infix"
                ]
        <*> (spaces *> Combine.Num.int)
        <*> (spaces *> (loName <|> operator))



-- Comments
-- --------


singleLineComment : Parser s Statement
singleLineComment =
    Comment <$> (string "--" *> regex ".*" <* whitespace)


multiLineComment : Parser s Statement
multiLineComment =
    (Comment << String.fromList) <$> (string "{-" *> manyTill anyChar (string "-}"))


comment : Parser s Statement
comment =
    singleLineComment <|> multiLineComment


{-| A parser for stand-alone Elm statements.
-}
statement : OpTable -> Parser s Statement
statement ops =
    choice
        [ portModuleDeclaration
        , effectModuleDeclaration
        , moduleDeclaration
        , importStatement
        , typeAliasDeclaration
        , typeDeclaration
        , portTypeDeclaration
        , portDeclaration ops
        , functionTypeDeclaration
        , functionDeclaration ops
        , infixDeclaration
        , comment
        ]


{-| A parser for a series of Elm statements.
-}
statements : OpTable -> Parser s (List Statement)
statements ops =
    manyTill (whitespace *> statement ops <* whitespace) end


{-| A scanner for infix statements. This is useful for performing a
first pass over a module to find all of the infix declarations in it.
-}
infixStatements : Parser s (List Statement)
infixStatements =
    let
        statements =
            many
                (choice
                    [ Just <$> infixDeclaration
                    , Nothing <$ regex ".*"
                    ]
                    <* whitespace
                )
                <* end
    in
        statements
            |> andThen
                (\xs ->
                    succeed <| List.filterMap identity xs
                )


{-| A scanner that returns an updated OpTable based on the infix
declarations in the input.
-}
opTable : OpTable -> Parser s OpTable
opTable ops =
    let
        collect s d =
            case s of
                InfixDeclaration a l n ->
                    Dict.insert n ( a, l ) d

                _ ->
                    Debug.crash "impossible"
    in
        infixStatements
            |> andThen
                (\xs ->
                    succeed <| List.foldr collect ops xs
                )
>>>>src/../elm-stuff/packages/Bogdanp/elm-ast/8.0.6/src/Ast.elm
module Ast
    exposing
        ( parseExpression
        , parseStatement
        , parseOpTable
        , parseModule
        , parse
        )

{-| This module exposes functions for parsing Elm code.


# Parsers

@docs parseExpression, parseStatement, parseOpTable, parseModule, parse

-}

import Combine exposing (end, (<*))
import Ast.BinOp exposing (OpTable, operators)
import Ast.Expression exposing (Expression, expression)
import Ast.Statement exposing (Statement, statement, statements, opTable)


{-| Parse an Elm expression.
-}
parseExpression : OpTable -> String -> Result (Combine.ParseErr ()) (Combine.ParseOk () Expression)
parseExpression ops =
    Combine.parse (expression ops <* end)


{-| Parse an Elm statement.
-}
parseStatement : OpTable -> String -> Result (Combine.ParseErr ()) (Combine.ParseOk () Statement)
parseStatement ops =
    Combine.parse (statement ops <* end)


{-| Parse an OpTable from a module.
-}
parseOpTable : OpTable -> String -> Result (Combine.ParseErr ()) (Combine.ParseOk () OpTable)
parseOpTable ops =
    Combine.parse (opTable ops)


{-| Parse an Elm module.
-}
parseModule : OpTable -> String -> Result (Combine.ParseErr ()) (Combine.ParseOk () (List Statement))
parseModule ops =
    Combine.parse (statements ops)


{-| Parse an Elm module, scanning for infix declarations first.
-}
parse : String -> Result (Combine.ParseErr ()) (Combine.ParseOk () (List Statement))
parse input =
    case parseOpTable operators input of
        Ok ( state, stream, ops ) ->
            parseModule ops input

        Err e ->
            (Err e)
>>>>src/../elm-stuff/packages/elm-community/list-extra/5.0.1/src/List/Extra.elm
module List.Extra
    exposing
        ( last
        , init
        , getAt
        , (!!)
        , uncons
        , minimumBy
        , maximumBy
        , andMap
        , andThen
        , takeWhile
        , dropWhile
        , unique
        , uniqueBy
        , allDifferent
        , allDifferentBy
        , replaceIf
        , setAt
        , swapAt
        , stableSortWith
        , remove
        , updateIf
        , updateAt
        , updateIfIndex
        , singleton
        , removeAt
        , filterNot
        , iterate
        , intercalate
        , transpose
        , subsequences
        , permutations
        , interweave
        , foldl1
        , foldr1
        , indexedFoldl
        , indexedFoldr
        , scanl1
        , scanr
        , scanr1
        , unfoldr
        , splitAt
        , takeWhileRight
        , dropWhileRight
        , span
        , break
        , stripPrefix
        , group
        , groupWhile
        , groupWhileTransitively
        , inits
        , tails
        , select
        , selectSplit
        , isPrefixOf
        , isSuffixOf
        , isInfixOf
        , isSubsequenceOf
        , isPermutationOf
        , notMember
        , find
        , elemIndex
        , elemIndices
        , findIndex
        , findIndices
        , zip
        , zip3
        , zip4
        , zip5
        , lift2
        , lift3
        , lift4
        , groupsOf
        , groupsOfWithStep
        , greedyGroupsOf
        , greedyGroupsOfWithStep
        , groupsOfVarying
        )

{-| Convenience functions for working with List

# Basics
@docs last, init, getAt, (!!), uncons, maximumBy, minimumBy, andMap, andThen, takeWhile, dropWhile, unique, uniqueBy, allDifferent, allDifferentBy, replaceIf, setAt, remove, updateIf, updateAt, updateIfIndex, singleton, removeAt, filterNot, swapAt, stableSortWith

# List transformations
@docs intercalate, transpose, subsequences, permutations, interweave

# Folds
@docs foldl1, foldr1, indexedFoldl, indexedFoldr

# Building lists
@docs scanl1, scanr, scanr1, unfoldr, iterate

# Sublists
@docs splitAt, takeWhileRight, dropWhileRight, span, break, stripPrefix, group, groupWhile, groupWhileTransitively, inits, tails, select, selectSplit

# Predicates
@docs isPrefixOf, isSuffixOf, isInfixOf, isSubsequenceOf, isPermutationOf

# Searching
@docs notMember, find, elemIndex, elemIndices, findIndex, findIndices

# Zipping
@docs zip, zip3, zip4, zip5

# Lift functions onto multiple lists of arguments
@docs lift2, lift3, lift4

# Split to groups of given size
@docs groupsOf, groupsOfWithStep, groupsOfVarying, greedyGroupsOf, greedyGroupsOfWithStep
-}

import List exposing (..)
import Set exposing (Set)
import Tuple exposing (first, second)


{-| Extract the last element of a list.

    last [1,2,3] == Just 3
    last [] == Nothing
-}
last : List a -> Maybe a
last =
    foldl1 (flip always)


{-| Return all elements of the list except the last one.

    init [1,2,3] == Just [1,2]
    init [] == Nothing
-}
init : List a -> Maybe (List a)
init =
    let
        maybe : b -> (List a -> b) -> Maybe (List a) -> b
        maybe d f =
            Maybe.withDefault d << Maybe.map f
    in
        foldr (\x -> maybe [] ((::) x) >> Just) Nothing


{-| Returns `Just` the element at the given index in the list,
or `Nothing` if the index is out of range.
-}
getAt : Int -> List a -> Maybe a
getAt idx xs =
    if idx < 0 then
        Nothing
    else
        List.head <| List.drop idx xs


{-| Alias for getAt, but with the parameters flipped.
-}
(!!) : List a -> Int -> Maybe a
(!!) =
    flip getAt


{-| Returns a list of repeated applications of `f`.

If `f` returns `Nothing` the iteration will stop. If it returns `Just y` then `y` will be added to the list and the iteration will continue with `f y`.
    nextYear : Int -> Maybe Int
    nextYear year =
      if year >= 2030 then
        Nothing
      else
        Just (year + 1)
    -- Will evaluate to [2010, 2011, ..., 2030]
    iterate nextYear 2010
-}
iterate : (a -> Maybe a) -> a -> List a
iterate f x =
    case f x of
        Just x_ ->
            x :: iterate f x_

        Nothing ->
            [ x ]


{-| Decompose a list into its head and tail. If the list is empty, return `Nothing`. Otherwise, return `Just (x, xs)`, where `x` is head and `xs` is tail.

    uncons [1,2,3] == Just (1, [2,3])
    uncons [] = Nothing
-}
uncons : List a -> Maybe ( a, List a )
uncons xs =
    case xs of
        [] ->
            Nothing

        x :: xs ->
            Just ( x, xs )


{-| Find the first maximum element in a list using a comparable transformation
-}
maximumBy : (a -> comparable) -> List a -> Maybe a
maximumBy f ls =
    let
        maxBy x ( y, fy ) =
            let
                fx =
                    f x
            in
                if fx > fy then
                    ( x, fx )
                else
                    ( y, fy )
    in
        case ls of
            [ l_ ] ->
                Just l_

            l_ :: ls_ ->
                Just <| first <| foldl maxBy ( l_, f l_ ) ls_

            _ ->
                Nothing


{-| Find the first minimum element in a list using a comparable transformation
-}
minimumBy : (a -> comparable) -> List a -> Maybe a
minimumBy f ls =
    let
        minBy x ( y, fy ) =
            let
                fx =
                    f x
            in
                if fx < fy then
                    ( x, fx )
                else
                    ( y, fy )
    in
        case ls of
            [ l_ ] ->
                Just l_

            l_ :: ls_ ->
                Just <| first <| foldl minBy ( l_, f l_ ) ls_

            _ ->
                Nothing


{-| Take elements in order as long as the predicate evaluates to `True`
-}
takeWhile : (a -> Bool) -> List a -> List a
takeWhile predicate =
    let
        takeWhileMemo memo list =
            case list of
                [] ->
                    List.reverse memo

                x :: xs ->
                    if (predicate x) then
                        takeWhileMemo (x :: memo) xs
                    else
                        List.reverse memo
    in
        takeWhileMemo []


{-| Drop elements in order as long as the predicate evaluates to `True`
-}
dropWhile : (a -> Bool) -> List a -> List a
dropWhile predicate list =
    case list of
        [] ->
            []

        x :: xs ->
            if (predicate x) then
                dropWhile predicate xs
            else
                list


{-| Remove duplicate values, keeping the first instance of each element which appears more than once.

    unique [0,1,1,0,1] == [0,1]
-}
unique : List comparable -> List comparable
unique list =
    uniqueHelp identity Set.empty list


{-| Drop duplicates where what is considered to be a duplicate is the result of first applying the supplied function to the elements of the list.
-}
uniqueBy : (a -> comparable) -> List a -> List a
uniqueBy f list =
    uniqueHelp f Set.empty list


{-| Indicate if list has duplicate values.

    allDifferent [0,1,1,0,1] == False
-}
allDifferent : List comparable -> Bool
allDifferent list =
    allDifferentBy identity list


{-| Indicate if list has duplicate values when supplied function are applyed on each values.
-}
allDifferentBy : (a -> comparable) -> List a -> Bool
allDifferentBy f list =
    List.length list == List.length (uniqueBy f list)


uniqueHelp : (a -> comparable) -> Set comparable -> List a -> List a
uniqueHelp f existing remaining =
    case remaining of
        [] ->
            []

        first :: rest ->
            let
                computedFirst =
                    f first
            in
                if Set.member computedFirst existing then
                    uniqueHelp f existing rest
                else
                    first :: uniqueHelp f (Set.insert computedFirst existing) rest


{-| Map functions taking multiple arguments over multiple lists. Each list should be of the same length.

    ((\a b c -> a + b * c)
        |> flip map [1,2,3]
        |> andMap [4,5,6]
        |> andMap [2,1,1]
    ) == [9,7,9]
-}
andMap : List a -> List (a -> b) -> List b
andMap l fl =
    map2 (<|) fl l


{-| Equivalent to `concatMap`. For example, suppose you want to have a cartesian product of [1,2] and [3,4]:

    [1,2] |> andThen (\x -> [3,4]
          |> andThen (\y -> [(x,y)]))

will give back the list:

    [(1,3),(1,4),(2,3),(2,4)]

Now suppose we want to have a cartesian product between the first list and the second list and its doubles:

    [1,2] |> andThen (\x -> [3,4]
          |> andThen (\y -> [y,y*2]
          |> andThen (\z -> [(x,z)])))

will give back the list:

    [(1,3),(1,6),(1,4),(1,8),(2,3),(2,6),(2,4),(2,8)]

Advanced functional programmers will recognize this as the implementation of bind operator (>>=) for lists from the `Monad` typeclass.
-}
andThen : (a -> List b) -> List a -> List b
andThen =
    concatMap


{-| Negation of `member`.

    notMember 1 [1,2,3] == False
    notMember 4 [1,2,3] == True
-}
notMember : a -> List a -> Bool
notMember x =
    not << member x


{-| Find the first element that satisfies a predicate and return
Just that element. If none match, return Nothing.

    find (\num -> num > 5) [2, 4, 6, 8] == Just 6
-}
find : (a -> Bool) -> List a -> Maybe a
find predicate list =
    case list of
        [] ->
            Nothing

        first :: rest ->
            if predicate first then
                Just first
            else
                find predicate rest


{-| Return the index of the first occurrence of the element. Otherwise, return `Nothing`. Indexing starts from 0.

    elemIndex 1 [1,2,3] == Just 0
    elemIndex 4 [1,2,3] == Nothing
    elemIndex 1 [1,2,1] == Just 0
-}
elemIndex : a -> List a -> Maybe Int
elemIndex x =
    findIndex ((==) x)


{-| Return all indices of occurrences of the element. If element is not found, return empty list. Indexing starts from 0.

    elemIndices 1 [1,2,3] == [0]
    elemIndices 4 [1,2,3] == []
    elemIndices 1 [1,2,1] == [0,2]
-}
elemIndices : a -> List a -> List Int
elemIndices x =
    findIndices ((==) x)


{-| Take a predicate and a list, return the index of the first element that satisfies the predicate. Otherwise, return `Nothing`. Indexing starts from 0.

    findIndex isEven [1,2,3] == Just 1
    findIndex isEven [1,3,5] == Nothing
    findIndex isEven [1,2,4] == Just 1
-}
findIndex : (a -> Bool) -> List a -> Maybe Int
findIndex p =
    head << findIndices p


{-| Take a predicate and a list, return indices of all elements satisfying the predicate. Otherwise, return empty list. Indexing starts from 0.

    findIndices isEven [1,2,3] == [1]
    findIndices isEven [1,3,5] == []
    findIndices isEven [1,2,4] == [1,2]
-}
findIndices : (a -> Bool) -> List a -> List Int
findIndices p =
    map first << filter (\( i, x ) -> p x) << indexedMap (,)


{-| Replace all values that satisfy a predicate with a replacement value.
-}
replaceIf : (a -> Bool) -> a -> List a -> List a
replaceIf predicate replacement list =
    updateIf predicate (always replacement) list


{-| Replace all values that satisfy a predicate by calling an update function.
-}
updateIf : (a -> Bool) -> (a -> a) -> List a -> List a
updateIf predicate update list =
    List.map
        (\item ->
            if predicate item then
                update item
            else
                item
        )
        list


{-| Replace a value at a specific index by calling an update function.
-}
updateAt : Int -> (a -> a) -> List a -> Maybe (List a)
updateAt index update list =
    if index < 0 || index >= List.length list then
        Nothing
    else
        Just <| updateIfIndex ((==) index) update list


{-| Replace a value at an index that satisfies a predicate.
-}
updateIfIndex : (Int -> Bool) -> (a -> a) -> List a -> List a
updateIfIndex predicate update list =
    List.indexedMap
        (\i x ->
            if predicate i then
                update x
            else
                x
        )
        list


{-| Remove the first occurrence of a value from a list.
-}
remove : a -> List a -> List a
remove x xs =
    case xs of
        [] ->
            []

        y :: ys ->
            if x == y then
                ys
            else
                y :: remove x ys


{-| Set a value in a list by index. Returns the updated list if the index is in range, or Nothing if it is out of range.
-}
setAt : Int -> a -> List a -> Maybe (List a)
setAt index value l =
    if index < 0 then
        Nothing
    else
        let
            head =
                List.take index l

            tail =
                List.drop index l |> List.tail
        in
            case tail of
                Nothing ->
                    Nothing

                Just t ->
                    Just (value :: t |> List.append head)


{-| Similar to List.sortWith, this sorts values with a custom comparison function.
    Unlike List.sortWith, this sort is guaranteed to be a stable sort.
    Note that List.sortWith is faster and is preferred if sort stability is not required.
-}
stableSortWith : (a -> a -> Basics.Order) -> List a -> List a
stableSortWith pred list =
    let
        listWithIndex =
            List.indexedMap (\i a -> ( a, i )) list

        predWithIndex ( a1, i1 ) ( a2, i2 ) =
            let
                result =
                    pred a1 a2
            in
                case result of
                    Basics.EQ ->
                        Basics.compare i1 i2

                    _ ->
                        result
    in
        List.sortWith predWithIndex listWithIndex |> List.map first


{-| Swap two values in a list by index. Returns the updated list if both indices
are in range, or Nothing if both are out of range. If the same index is
supplied twice the original list is returned.
-}
swapAt : Int -> Int -> List a -> Maybe (List a)
swapAt index1 index2 l =
    if index1 == index2 then
        Just l
    else if index1 > index2 then
        swapAt index2 index1 l
    else if index1 < 0 then
        Nothing
    else
        let
            ( part1, tail1 ) =
                splitAt index1 l

            ( head2, tail2 ) =
                splitAt (index2 - index1) tail1
        in
            Maybe.map2
                (\( value1, part2 ) ( value2, part3 ) ->
                    List.concat [ part1, value2 :: part2, value1 :: part3 ]
                )
                (uncons head2)
                (uncons tail2)


{-| Convert a value to a list containing one value.

    singleton 3 == [3]
-}
singleton : a -> List a
singleton x =
    [ x ]


{-| Remove the element at an index from a list. If the index is out of range, this returns the original list unchanged. Otherwise, it returns the updated list.
-}
removeAt : Int -> List a -> List a
removeAt index l =
    if index < 0 then
        l
    else
        let
            head =
                List.take index l

            tail =
                List.drop index l |> List.tail
        in
            case tail of
                Nothing ->
                    l

                Just t ->
                    List.append head t


{-| Take a predicate and a list, and return a list that contains elements which fails to satisfy the predicate.
    This is equivalent to `List.filter (not << predicate) list`.

    filterNot isEven [1,2,3,4] == [1,3]
-}
filterNot : (a -> Bool) -> List a -> List a
filterNot pred list =
    List.filter (not << pred) list


{-| Take a list and a list of lists, insert that list between every list in the list of lists, concatenate the result. `intercalate xs xss` is equivalent to `concat (intersperse xs xss)`.

    intercalate [0,0] [[1,2],[3,4],[5,6]] == [1,2,0,0,3,4,0,0,5,6]
-}
intercalate : List a -> List (List a) -> List a
intercalate xs =
    concat << intersperse xs


{-| Transpose rows and columns of the list of lists.

    transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]

If some rows are shorter than the following rows, their elements are skipped:

    transpose [[10,11],[20],[],[30,31,32]] == [[10,20,30],[11,31],[32]]
-}
transpose : List (List a) -> List (List a)
transpose ll =
    case ll of
        [] ->
            []

        [] :: xss ->
            transpose xss

        (x :: xs) :: xss ->
            let
                heads =
                    filterMap head xss

                tails =
                    filterMap tail xss
            in
                (x :: heads) :: transpose (xs :: tails)


{-| Return the list of all subsequences of a list.

    subsequences [1,2,3] == [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
-}
subsequences : List a -> List (List a)
subsequences xs =
    [] :: subsequencesNonEmpty xs


{-| Return the list of all subsequences of the argument, except for the empty list.

    subsequencesNonEmpty [1,2,3] == [[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
-}
subsequencesNonEmpty : List a -> List (List a)
subsequencesNonEmpty xs =
    case xs of
        [] ->
            []

        x :: xs ->
            let
                f ys r =
                    ys :: (x :: ys) :: r
            in
                [ x ] :: foldr f [] (subsequencesNonEmpty xs)


{-| Return the list of of all permutations of a list. The result is in lexicographic order.

    permutations [1,2,3] == [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
-}
permutations : List a -> List (List a)
permutations xs_ =
    case xs_ of
        [] ->
            [ [] ]

        xs ->
            let
                f ( y, ys ) =
                    map ((::) y) (permutations ys)
            in
                concatMap f (select xs)


{-| Return a list that contains elements from the two provided, in alternate order.
    If one list runs out of items, append the items from the remaining list.

    interweave [1,3] [2,4] == [1,2,3,4]
    interweave [1,3,5,7] [2,4] == [1,2,3,4,5,7]
-}
interweave : List a -> List a -> List a
interweave l1 l2 =
    interweaveHelp l1 l2 []


interweaveHelp : List a -> List a -> List a -> List a
interweaveHelp l1 l2 acc =
    case ( l1, l2 ) of
        ( x :: xs, y :: ys ) ->
            interweaveHelp xs ys <| acc ++ [ x, y ]

        ( x, [] ) ->
            acc ++ x

        ( [], y ) ->
            acc ++ y


{-| Variant of `foldl` that has no starting value argument and treats the head of the list as its starting value. If the list is empty, return `Nothing`.

    foldl1 max [1,2,3,2,1] == Just 3
    foldl1 max [] == Nothing
    foldl1 (-) [1,2,3] == Just -4
-}
foldl1 : (a -> a -> a) -> List a -> Maybe a
foldl1 f xs =
    let
        mf x m =
            Just
                (case m of
                    Nothing ->
                        x

                    Just y ->
                        f y x
                )
    in
        List.foldl mf Nothing xs


{-| Variant of `foldr` that has no starting value argument and treats the last element of the list as its starting value. If the list is empty, return `Nothing`.

    foldr1 min [1,2,3,2,1] == Just 1
    foldr1 min [] == Nothing
    foldr1 (-) [1,2,3] == Just 2
-}
foldr1 : (a -> a -> a) -> List a -> Maybe a
foldr1 f xs =
    let
        mf x m =
            Just
                (case m of
                    Nothing ->
                        x

                    Just y ->
                        f x y
                )
    in
        List.foldr mf Nothing xs


{-| Variant of `foldl` that passes the index of the current element to the step function. `indexedFoldl` is to `List.foldl` as `List.indexedMap` is to `List.map`.
-}
indexedFoldl : (Int -> a -> b -> b) -> b -> List a -> b
indexedFoldl func acc list =
    let
        step x ( i, acc ) =
            ( i + 1, func i x acc )
    in
        second (List.foldl step ( 0, acc ) list)


{-| Variant of `foldr` that passes the index of the current element to the step function. `indexedFoldr` is to `List.foldr` as `List.indexedMap` is to `List.map`.
-}
indexedFoldr : (Int -> a -> b -> b) -> b -> List a -> b
indexedFoldr func acc list =
    let
        step x ( i, acc ) =
            ( i - 1, func i x acc )
    in
        second (List.foldr step ( List.length list - 1, acc ) list)


{-| `scanl1` is a variant of `scanl` that has no starting value argument.

Compare:

    List.scanl (+) 0 [1,2,3] == [0,1,3,6]
    scanl1 (+) [1,2,3] == [1,3,6]

    List.scanl (-) 0 [1,2,3] == [0,1,1,2]
    scanl1 (-) [1,2,3] == [1,1,2]

    List.scanl (flip (-)) 0 [1,2,3] == [0,-1,-3,-6]
    scanl1 (flip (-)) [1,2,3] == [1,-1,-4]
-}
scanl1 : (a -> a -> a) -> List a -> List a
scanl1 f xs_ =
    case xs_ of
        [] ->
            []

        x :: xs ->
            scanl f x xs


{-| `scanr` is a right-to-left dual of `scanl`. Note that:

    head (scanr f z xs) == foldr f z xs

Examples:

    scanr (+) 0 [1,2,3] == [6,5,3,0]
    scanr (-) 0 [1,2,3] == [2,-1,3,0]
-}
scanr : (a -> b -> b) -> b -> List a -> List b
scanr f acc xs_ =
    case xs_ of
        [] ->
            [ acc ]

        x :: xs ->
            case scanr f acc xs of
                (q :: _) as qs ->
                    f x q :: qs

                [] ->
                    []


{-| `scanr1` is a variant of `scanr` that has no starting value argument.

    scanr1 (+) [1,2,3] == [6,5,3]
    scanr1 (-) [1,2,3] == [2,-1,3]
    scanr1 (flip (-)) [1,2,3] == [0,1,3]
-}
scanr1 : (a -> a -> a) -> List a -> List a
scanr1 f xs_ =
    case xs_ of
        [] ->
            []

        [ x ] ->
            [ x ]

        x :: xs ->
            case scanr1 f xs of
                (q :: _) as qs ->
                    f x q :: qs

                [] ->
                    []


{-| The `unfoldr` function is "dual" to `foldr`. `foldr` reduces a list to a summary value, `unfoldr` builds a list from a seed. The function takes a function and a starting element. It applies the function to the element. If the result is `Just (a, b)`, `a` is accumulated and the function is applied to `b`. If the result is `Nothing`, the list accumulated so far is returned.

    unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 5 == [5,4,3,2,1]
-}
unfoldr : (b -> Maybe ( a, b )) -> b -> List a
unfoldr f seed =
    case f seed of
        Nothing ->
            []

        Just ( a, b ) ->
            a :: unfoldr f b


{-| Take a number and a list, return a tuple of lists, where first part is prefix of the list of length equal the number, and second part is the remainder of the list. `splitAt n xs` is equivalent to `(take n xs, drop n xs)`.

    splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
    splitAt 1 [1,2,3] == ([1],[2,3])
    splitAt 3 [1,2,3] == ([1,2,3],[])
    splitAt 4 [1,2,3] == ([1,2,3],[])
    splitAt 0 [1,2,3] == ([],[1,2,3])
    splitAt (-1) [1,2,3] == ([],[1,2,3])
-}
splitAt : Int -> List a -> ( List a, List a )
splitAt n xs =
    ( take n xs, drop n xs )


{-| Take elements from the right, while predicate still holds.

    takeWhileRight ((<)5) (range 1 10) == [6,7,8,9,10]
-}
takeWhileRight : (a -> Bool) -> List a -> List a
takeWhileRight p =
    let
        step x ( xs, free ) =
            if p x && free then
                ( x :: xs, True )
            else
                ( xs, False )
    in
        first << foldr step ( [], True )


{-| Drop elements from the right, while predicate still holds.

    dropWhileRight ((<)5) (range 1 10) == [1,2,3,4,5]
-}
dropWhileRight : (a -> Bool) -> List a -> List a
dropWhileRight p =
    foldr
        (\x xs ->
            if p x && isEmpty xs then
                []
            else
                x :: xs
        )
        []


{-| Take a predicate and a list, return a tuple. The first part of the tuple is the longest prefix of that list, for each element of which the predicate holds. The second part of the tuple is the remainder of the list. `span p xs` is equivalent to `(takeWhile p xs, dropWhile p xs)`.

    span ((>) 3) [1,2,3,4,1,2,3,4] == ([1,2],[3,4,1,2,3,4])
    span ((>) 5) [1,2,3] == ([1,2,3],[])
    span ((>) 0) [1,2,3] == ([],[1,2,3])
-}
span : (a -> Bool) -> List a -> ( List a, List a )
span p xs =
    ( takeWhile p xs, dropWhile p xs )


{-| Take a predicate and a list, return a tuple. The first part of the tuple is the longest prefix of that list, for each element of which the predicate *does not* hold. The second part of the tuple is the remainder of the list. `break p xs` is equivalent to `(takeWhile (not p) xs, dropWhile (not p) xs)`.

    break ((<) 3) [1,2,3,4,1,2,3,4] == ([1,2,3],[4,1,2,3,4])
    break ((>) 5) [1,2,3] == ([],[1,2,3])
    break ((<) 5) [1,2,3] == ([1,2,3],[])
-}
break : (a -> Bool) -> List a -> ( List a, List a )
break p =
    span (not << p)


{-| Drop the given prefix from the list. If the list doesn't start with that prefix, return `Nothing`.

    stripPrefix [1,2] [1,2,3,4] == Just [3,4]
    stripPrefix [1,2,3] [1,2,3,4,5] == Just [4,5]
    stripPrefix [1,2,3] [1,2,3] == Just []
    stripPrefix [1,2,3] [1,2] == Nothing
    stripPrefix [3,2,1] [1,2,3,4,5] == Nothing
-}
stripPrefix : List a -> List a -> Maybe (List a)
stripPrefix prefix xs =
    let
        step e m =
            case m of
                Nothing ->
                    Nothing

                Just [] ->
                    Nothing

                Just (x :: xs_) ->
                    if e == x then
                        Just xs_
                    else
                        Nothing
    in
        foldl step (Just xs) prefix


{-| Group similar elements together. `group` is equivalent to `groupWhile (==)`.

    group [1,2,2,3,3,3,2,2,1] == [[1],[2,2],[3,3,3],[2,2],[1]]
-}
group : List a -> List (List a)
group =
    groupWhile (==)


{-| Group elements together, using a custom equality test.

    groupWhile (\x y -> first x == first y) [(0,'a'),(0,'b'),(1,'c'),(1,'d')] == [[(0,'a'),(0,'b')],[(1,'c'),(1,'d')]]

The equality test should be an equivalent relationship, i.e. it should have the properties of reflexivity, symmetry, and transitivity. For non-equivalent relations it gives non-intuitive behavior:

    groupWhile (<) [1,2,3,2,4,1,3,2,1] == [[1,2,3,2,4],[1,3,2],[1]]

For grouping elements with a comparison test, which must only hold the property of transitivity, see `groupWhileTransitively`.
-}
groupWhile : (a -> a -> Bool) -> List a -> List (List a)
groupWhile eq xs_ =
    case xs_ of
        [] ->
            []

        x :: xs ->
            let
                ( ys, zs ) =
                    span (eq x) xs
            in
                (x :: ys) :: groupWhile eq zs


{-| Group elements together, using a custom comparison test. Start a new group each time the comparison test doesn't hold for two adjacent elements.

    groupWhileTransitively (<) [1,2,3,2,4,1,3,2,1] == [[1,2,3],[2,4],[1,3],[2],[1]]
-}
groupWhileTransitively : (a -> a -> Bool) -> List a -> List (List a)
groupWhileTransitively cmp xs_ =
    case xs_ of
        [] ->
            []

        [ x ] ->
            [ [ x ] ]

        x :: ((x_ :: _) as xs) ->
            case groupWhileTransitively cmp xs of
                (y :: ys) as r ->
                    if cmp x x_ then
                        (x :: y) :: ys
                    else
                        [ x ] :: r

                [] ->
                    []


{-| Return all initial segments of a list, from shortest to longest, empty list first, the list itself last.

    inits [1,2,3] == [[],[1],[1,2],[1,2,3]]
-}
inits : List a -> List (List a)
inits =
    foldr (\e acc -> [] :: map ((::) e) acc) [ [] ]


{-| Return all final segments of a list, from longest to shortest, the list itself first, empty list last.

    tails [1,2,3] == [[1,2,3],[2,3],[3],[]]
-}
tails : List a -> List (List a)
tails =
    foldr tailsHelp [ [] ]


tailsHelp : a -> List (List a) -> List (List a)
tailsHelp e list =
    case list of
        x :: xs ->
            (e :: x) :: x :: xs

        [] ->
            []


{-| Return all combinations in the form of (element, rest of the list). Read [Haskell Libraries proposal](https://mail.haskell.org/pipermail/libraries/2008-February/009270.html) for further ideas on how to use this function.

    select [1,2,3,4] == [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
-}
select : List a -> List ( a, List a )
select xs =
    case xs of
        [] ->
            []

        x :: xs ->
            ( x, xs ) :: map (\( y, ys ) -> ( y, x :: ys )) (select xs)


{-| Return all combinations in the form of (elements before, element, elements after).

    selectSplit [1,2,3] == [([],1,[2,3]),([1],2,[3]),([1,2],3,[])]
-}
selectSplit : List a -> List ( List a, a, List a )
selectSplit xs =
    case xs of
        [] ->
            []

        x :: xs ->
            ( [], x, xs ) :: map (\( lys, y, rys ) -> ( x :: lys, y, rys )) (selectSplit xs)


{-| Take 2 lists and return True, if the first list is the prefix of the second list.
-}
isPrefixOf : List a -> List a -> Bool
isPrefixOf prefix xs =
    case ( prefix, xs ) of
        ( [], _ ) ->
            True

        ( _ :: _, [] ) ->
            False

        ( p :: ps, x :: xs ) ->
            p == x && isPrefixOf ps xs


{-| Take 2 lists and return True, if the first list is the suffix of the second list.
-}
isSuffixOf : List a -> List a -> Bool
isSuffixOf suffix xs =
    isPrefixOf (reverse suffix) (reverse xs)


{-| Take 2 lists and return True, if the first list is an infix of the second list.
-}
isInfixOf : List a -> List a -> Bool
isInfixOf infix xs =
    any (isPrefixOf infix) (tails xs)


{-| Take 2 lists and return True, if the first list is a subsequence of the second list.
-}
isSubsequenceOf : List a -> List a -> Bool
isSubsequenceOf subseq xs =
    member subseq (subsequences xs)


{-| Take 2 lists and return True, if the first list is a permutation of the second list.
-}
isPermutationOf : List a -> List a -> Bool
isPermutationOf permut xs =
    member permut (permutations xs)


{-| Take two lists and returns a list of corresponding pairs
-}
zip : List a -> List b -> List ( a, b )
zip =
    map2 (,)


{-| Take three lists and returns a list of triples
-}
zip3 : List a -> List b -> List c -> List ( a, b, c )
zip3 =
    map3 (,,)


{-| Take four lists and returns a list of quadruples
-}
zip4 : List a -> List b -> List c -> List d -> List ( a, b, c, d )
zip4 =
    map4 (,,,)


{-| Take five lists and returns a list of quintuples
-}
zip5 : List a -> List b -> List c -> List d -> List e -> List ( a, b, c, d, e )
zip5 =
    map5 (,,,,)


{-| Map functions taking multiple arguments over multiple lists, regardless of list length.
  All possible combinations will be explored.

  lift2 (+) [1,2,3] [4,5] == [5,6,6,7,7,8]
-}
lift2 : (a -> b -> c) -> List a -> List b -> List c
lift2 f la lb =
    la |> andThen (\a -> lb |> andThen (\b -> [ f a b ]))


{-|
-}
lift3 : (a -> b -> c -> d) -> List a -> List b -> List c -> List d
lift3 f la lb lc =
    la |> andThen (\a -> lb |> andThen (\b -> lc |> andThen (\c -> [ f a b c ])))


{-|
-}
lift4 : (a -> b -> c -> d -> e) -> List a -> List b -> List c -> List d -> List e
lift4 f la lb lc ld =
    la |> andThen (\a -> lb |> andThen (\b -> lc |> andThen (\c -> ld |> andThen (\d -> [ f a b c d ]))))


{-| Split list into groups of size given by the first argument.

    groupsOf 3 (range 1 10) == [[1,2,3],[4,5,6],[7,8,9]]
-}
groupsOf : Int -> List a -> List (List a)
groupsOf size xs =
    groupsOfWithStep size size xs


{-| Split list into groups of size given by the first argument.  After each group, drop a number of elements given by the second argument before starting the next group.

    groupsOfWithStep 2 1 (range 1 4) == [[1,2],[2,3],[3,4]]
-}
groupsOfWithStep : Int -> Int -> List a -> List (List a)
groupsOfWithStep size step xs =
    let
        group =
            List.take size xs

        xs_ =
            List.drop step xs

        okayArgs =
            size > 0 && step > 0

        okayLength =
            size == List.length group
    in
        if okayArgs && okayLength then
            group :: groupsOfWithStep size step xs_
        else
            []


{-| `groupsOfVarying ns` takes `n` elements from a list for each `n` in `ns`, splitting the list into variably sized segments

    groupsOfVarying [2, 3, 1] ["a", "b", "c", "d", "e", "f"] == [["a", "b"], ["c", "d", "e"], ["f"]]
    groupsOfVarying [2] ["a", "b", "c", "d", "e", "f"] == [["a", "b"]]
    groupsOfVarying [2, 3, 1, 5, 6] ["a", "b", "c", "d", "e"] == [["a", "b"], ["c", "d", "e"]]
-}
groupsOfVarying : List Int -> List a -> List (List a)
groupsOfVarying listOflengths list =
    groupsOfVarying_ listOflengths list []


groupsOfVarying_ : List Int -> List a -> List (List a) -> List (List a)
groupsOfVarying_ listOflengths list accu =
    case ( listOflengths, list ) of
        ( length :: tailLengths, _ :: _ ) ->
            let
                ( head, tail ) =
                    splitAt length list
            in
                groupsOfVarying_ tailLengths tail (head :: accu)

        _ ->
            List.reverse accu


{-| Split list into groups of size given by the first argument "greedily" (don't throw the group away if not long enough).

    greedyGroupsOf 3 (range 1 10) == [[1,2,3],[4,5,6],[7,8,9],[10]]
-}
greedyGroupsOf : Int -> List a -> List (List a)
greedyGroupsOf size xs =
    greedyGroupsOfWithStep size size xs


{-| Split list into groups of size given by the first argument "greedily" (don't throw the group away if not long enough). After each group, drop a number of elements given by the second argumet before starting the next group.

    greedyGroupsOfWithStep 3 2 (range 1 6) == [[1,2,3],[3,4,5],[5,6]]
-}
greedyGroupsOfWithStep : Int -> Int -> List a -> List (List a)
greedyGroupsOfWithStep size step xs =
    let
        group =
            List.take size xs

        xs_ =
            List.drop step xs

        okayArgs =
            size > 0 && step > 0

        okayXs =
            List.length xs > 0
    in
        if okayArgs && okayXs then
            group :: greedyGroupsOfWithStep size step xs_
        else
            []
>>>>src/../elm-stuff/packages/elm-community/parser-combinators/1.1.0/examples/Calc.elm
module Calc exposing (calc)

{-| An example parser that computes arithmetic expressions.

@docs calc
-}

import Combine exposing (..)
import Combine.Num exposing (int)


addop : Parser s (Int -> Int -> Int)
addop =
    choice
        [ (+) <$ string "+"
        , (-) <$ string "-"
        ]


mulop : Parser s (Int -> Int -> Int)
mulop =
    choice
        [ (*) <$ string "*"
        , (//) <$ string "/"
        ]


expr : Parser s Int
expr =
    let
        go () =
            chainl addop term
    in
        lazy go


term : Parser s Int
term =
    let
        go () =
            chainl mulop factor
    in
        lazy go


factor : Parser s Int
factor =
    whitespace *> (parens expr <|> int) <* whitespace


{-| Compute the result of an expression.
-}
calc : String -> Result String Int
calc s =
    case parse (expr <* end) s of
        Ok ( _, _, n ) ->
            Ok n

        Err ( _, stream, ms ) ->
            Err ("parse error: " ++ toString ms ++ ", " ++ toString stream)
>>>>src/../elm-stuff/packages/elm-community/parser-combinators/1.1.0/examples/Python.elm
module Python exposing (..)

import Combine exposing (..)
import Combine.Char exposing (..)
import Combine.Num
import String


type Expression
    = EBool Bool
    | EInt Int
    | EFloat Float
    | EString String
    | EOr Expression Expression
    | EAnd Expression Expression
    | ENot Expression
    | ECmp String Expression Expression
    | EAdd Expression Expression
    | ESub Expression Expression
    | EMul Expression Expression
    | EDiv Expression Expression
    | EList (List Expression)
    | ETuple (List Expression)
    | EDict (List ( Expression, Expression ))
    | ESet (List Expression)
    | EIdentifier String
    | EAttribute Expression Expression
    | EApp Expression (List Expression)
    | EAssign Expression Expression


type Statement
    = SExpr Expression
    | SPrint (List Expression)
    | SDel (List Expression)
    | SPass
    | SBreak
    | SContinue
    | SReturn (Maybe Expression)
    | SRaise (Maybe (List Expression))
    | SImport (List ( Expression, Maybe Expression ))
    | SImportFrom Expression (List ( Expression, Maybe Expression ))
    | SGlobal (List Expression)
    | SAssert Expression (Maybe Expression)
    | SAssign Expression


type CompoundStatement
    = CSimple (List Statement)
    | CWhile Expression (List CompoundStatement)
    | CFor Expression Expression (List CompoundStatement)
    | CWith Expression (Maybe Expression) (List CompoundStatement)
    | CFunc Expression (List Expression) (List CompoundStatement)


type alias Indentation =
    List Int


initIndentation : Indentation
initIndentation =
    [ 0 ]


dropWhile : (a -> Bool) -> List a -> List a
dropWhile p xs =
    case xs of
        [] ->
            []

        x :: ys ->
            if p x then
                dropWhile p ys
            else
                xs


comment : Parser s String
comment =
    regex "#[^\n]*"


spaces : Parser s String
spaces =
    regex " *"


whitespace : Parser s String
whitespace =
    comment <|> spaces <?> "whitespace"


token : Parser s res -> Parser s res
token =
    between whitespace whitespace


keyword : String -> Parser s String
keyword s =
    string s <* spaces


bool : Parser s Expression
bool =
    EBool
        <$> choice
                [ False <$ string "False"
                , True <$ string "True"
                ]
        <?> "boolean"


int : Parser s Expression
int =
    EInt <$> Combine.Num.int <?> "integer"


float : Parser s Expression
float =
    EFloat <$> Combine.Num.float <?> "float"


str : Parser s Expression
str =
    EString
        <$> choice
                [ string "'" *> regex "(\\\\'|[^'\n])*" <* string "'"
                , string "\"" *> regex "(\\\\\"|[^\"\n])*" <* string "\""
                ]
        <?> "string"


identifier : Parser s Expression
identifier =
    EIdentifier <$> regex "[_a-zA-Z][_a-zA-Z0-9]*" <?> "identifier"


attribute : Parser s Expression
attribute =
    lazy <|
        \() ->
            EAttribute
                <$> identifier
                <* string "."
                <*> choice [ attribute, identifier ]
                <?> "attribute"


app : Parser s Expression
app =
    lazy <|
        \() ->
            EApp
                <$> choice [ attribute, identifier ]
                <*> parens exprList
                <?> "function call"


commaSep : Parser s String
commaSep =
    regex ", *"


dictSep : Parser s String
dictSep =
    regex ":[ \t\x0D\n]*"


listSep : Parser s String
listSep =
    regex ",[ \t\x0D\n]*"


list : Parser s Expression
list =
    lazy <|
        \() ->
            EList
                <$> brackets (sepBy listSep expr)
                <?> "list"


tuple : Parser s Expression
tuple =
    lazy <|
        \() ->
            ETuple
                <$> parens (sepBy listSep expr)
                <?> "tuple"


dict : Parser s Expression
dict =
    lazy <|
        \() ->
            EDict
                <$> brackets (sepBy listSep ((,) <$> expr <* dictSep <*> expr))
                <?> "dictionary"


set : Parser s Expression
set =
    lazy <|
        \() ->
            ESet
                <$> brackets (sepBy listSep expr)
                <?> "set"


atom : Parser s Expression
atom =
    lazy <|
        \() ->
            choice [ bool, float, int, str, attribute, identifier, list, tuple, dict, set ]


expr : Parser s Expression
expr =
    lazy (\() -> chainl orop andExpr)


andExpr : Parser s Expression
andExpr =
    lazy (\() -> chainl andop notExpr)


notExpr : Parser s Expression
notExpr =
    lazy <|
        \() ->
            (token <| ENot <$> (string "not" *> notExpr)) <|> cmpExpr


cmpExpr : Parser s Expression
cmpExpr =
    lazy (\() -> chainl cmpop arithExpr)


arithExpr : Parser s Expression
arithExpr =
    lazy (\() -> chainl addop term)


term : Parser s Expression
term =
    lazy (\() -> chainl mulop factor)


factor : Parser s Expression
factor =
    lazy (\() -> token (parens expr <|> app <|> atom))


orop : Parser s (Expression -> Expression -> Expression)
orop =
    EOr <$ string "or"


andop : Parser s (Expression -> Expression -> Expression)
andop =
    EAnd <$ string "and"


cmpop : Parser s (Expression -> Expression -> Expression)
cmpop =
    ECmp
        <$> choice
                [ string "<"
                , string ">"
                , string "=="
                , string "!="
                , string ">="
                , string "<="
                , string "in"
                , (++) <$> keyword "not" <*> string "in"
                , string "is"
                , (++) <$> keyword "is" <*> string "not"
                ]


addop : Parser s (Expression -> Expression -> Expression)
addop =
    choice
        [ EAdd <$ string "+"
        , ESub <$ string "-"
        ]


mulop : Parser s (Expression -> Expression -> Expression)
mulop =
    choice
        [ EMul <$ string "*"
        , EDiv <$ string "/"
        ]


exprList : Parser s (List Expression)
exprList =
    sepBy commaSep expr


exprStmt : Parser s Statement
exprStmt =
    SExpr <$> expr <?> "expression"


printStmt : Parser s Statement
printStmt =
    SPrint <$> (keyword "print" *> exprList) <?> "print statement"


delStmt : Parser s Statement
delStmt =
    SDel <$> (keyword "del" *> exprList) <?> "del statement"


passStmt : Parser s Statement
passStmt =
    SPass <$ keyword "pass" <?> "pass statement"


breakStmt : Parser s Statement
breakStmt =
    SBreak <$ keyword "break" <?> "break statement"


continueStmt : Parser s Statement
continueStmt =
    SContinue <$ keyword "continue" <?> "continue statement"


returnStmt : Parser s Statement
returnStmt =
    SReturn <$> (keyword "return" *> maybe expr) <?> "return statement"


raiseStmt : Parser s Statement
raiseStmt =
    SRaise <$> (keyword "raise" *> maybe exprList) <?> "raise statement"


importAs : Parser s (List ( Expression, Maybe Expression ))
importAs =
    sepBy commaSep <|
        (,)
            <$> choice [ attribute, identifier ]
            <*> maybe (whitespace *> keyword "as" *> identifier)


importStmt : Parser s Statement
importStmt =
    SImport
        <$> (keyword "import" *> importAs)
        <?> "import statement"


importFromStmt : Parser s Statement
importFromStmt =
    SImportFrom
        <$> (keyword "from" *> choice [ attribute, identifier ] <* spaces)
        <*> (keyword "import" *> importAs)
        <?> "from statement"


globalStmt : Parser s Statement
globalStmt =
    SGlobal <$> (keyword "global" *> sepBy commaSep identifier)


assertStmt : Parser s Statement
assertStmt =
    SAssert
        <$> (keyword "assert" *> expr)
        <*> maybe (commaSep *> expr)


assignop : Parser s (Expression -> Expression -> Expression)
assignop =
    EAssign <$ token (string "=")


assignStmt : Parser s Statement
assignStmt =
    SAssign <$> chainr assignop expr


indentation : Parser Indentation res -> Parser Indentation res
indentation p =
    let
        skipIndent stack =
            let
                current =
                    List.head stack
                        |> Maybe.withDefault 0

                validate s =
                    let
                        indent =
                            String.length s
                    in
                        if indent == current then
                            succeed ()
                        else
                            fail ("expected " ++ toString current ++ " spaces of indentation")
            in
                spaces >>= validate
    in
        withState skipIndent *> p


indent : Parser Indentation ()
indent =
    lazy <|
        \() ->
            let
                push s =
                    withState <|
                        \stack ->
                            let
                                indent =
                                    String.length s
                            in
                                case stack of
                                    [] ->
                                        fail "negative indentation"

                                    current :: _ ->
                                        if indent > current then
                                            putState (indent :: stack)
                                        else
                                            fail "expected indentation"
            in
                lookAhead <| spaces >>= push


dedent : Parser Indentation ()
dedent =
    lazy <|
        \() ->
            let
                pop s =
                    withState <|
                        \stack ->
                            let
                                rem =
                                    dropWhile ((/=) (String.length s)) stack
                            in
                                case rem of
                                    _ :: _ ->
                                        putState rem

                                    _ ->
                                        fail "unindent does not match any outer indentation level"
            in
                spaces >>= pop


block : Parser Indentation (List CompoundStatement)
block =
    lazy <|
        \() ->
            string ":"
                *> whitespace
                *> eol
                *> indent
                *> many1 stmt
                <* dedent


blockStmt : Parser Indentation (List CompoundStatement -> CompoundStatement) -> Parser Indentation CompoundStatement
blockStmt p =
    indentation p
        |> andThen
            (\f ->
                block
                    |> andThen (\ss -> succeed (f ss))
            )


simpleStmt : Parser Indentation CompoundStatement
simpleStmt =
    lazy <|
        \() ->
            let
                stmt =
                    choice
                        [ assertStmt
                        , globalStmt
                        , importFromStmt
                        , importStmt
                        , raiseStmt
                        , returnStmt
                        , continueStmt
                        , breakStmt
                        , passStmt
                        , delStmt
                        , printStmt
                        , assignStmt
                        , exprStmt
                        ]
            in
                indentation (CSimple <$> sepBy (string ";" <* whitespace) stmt <* (() <$ eol <|> end))


whileStmt : Parser s (List CompoundStatement -> CompoundStatement)
whileStmt =
    CWhile <$> (keyword "while" *> expr)


forStmt : Parser s (List CompoundStatement -> CompoundStatement)
forStmt =
    CFor
        <$> (keyword "for" *> identifier)
        <*> (spaces *> keyword "in" *> expr)


withStmt : Parser s (List CompoundStatement -> CompoundStatement)
withStmt =
    CWith
        <$> (keyword "with" *> expr)
        <*> maybe (keyword "as" *> identifier)


funcStmt : Parser s (List CompoundStatement -> CompoundStatement)
funcStmt =
    CFunc
        <$> (keyword "def" *> identifier)
        <*> parens (sepBy commaSep identifier)


compoundStmt : Parser Indentation CompoundStatement
compoundStmt =
    lazy <|
        \() ->
            let
                parsers =
                    List.map blockStmt
                        [ whileStmt
                        , forStmt
                        , withStmt
                        , funcStmt
                        ]
            in
                choice parsers


stmt : Parser Indentation CompoundStatement
stmt =
    lazy <|
        \() ->
            compoundStmt <|> simpleStmt


program : Parser Indentation (List CompoundStatement)
program =
    manyTill stmt end


formatError : List String -> InputStream -> String
formatError ms stream =
    let
        location =
            currentLocation stream

        separator =
            "| "

        expectationSeparator =
            "\n  * "

        lineNumberOffset =
            floor (logBase 10 (toFloat location.line)) + 1

        separatorOffset =
            String.length separator

        padding =
            location.column + separatorOffset + 2
    in
        "Parse error around line:\n\n"
            ++ toString location.line
            ++ separator
            ++ location.source
            ++ "\n"
            ++ String.padLeft padding ' ' "^"
            ++ "\nI expected one of the following:\n"
            ++ expectationSeparator
            ++ String.join expectationSeparator ms


parse : String -> Result String (List CompoundStatement)
parse s =
    case Combine.runParser program initIndentation s of
        Ok ( _, _, es ) ->
            Ok es

        Err ( _, stream, ms ) ->
            Err <| formatError ms stream


test : Result String (List CompoundStatement)
test =
    parse """import os

a = b = 1

def rel(p):
  return os.path.join(os.path.dirname(__file__), p)

def f(a, b):
  return a + b

with open(rel('Python.elm')) as f:
  for line in f:
    print f
"""
>>>>src/../elm-stuff/packages/elm-community/parser-combinators/1.1.0/examples/Scheme.elm
module Scheme exposing (..)

import Combine exposing (..)
import Combine.Char exposing (anyChar)
import Combine.Num
import String


type E
    = EBool Bool
    | EInt Int
    | EFloat Float
    | EChar Char
    | EString String
    | EIdentifier String
    | EList (List E)
    | EVector (List E)
    | EQuote E
    | EQuasiquote E
    | EUnquote E
    | EUnquoteSplice E
    | EComment String


comment : Parser s E
comment =
    EComment
        <$> regex ";[^\n]+"
        <?> "comment"


bool : Parser s E
bool =
    let
        boolLiteral =
            choice
                [ True <$ string "#t"
                , False <$ string "#f"
                ]
    in
        EBool
            <$> boolLiteral
            <?> "boolean literal"


int : Parser s E
int =
    EInt
        <$> Combine.Num.int
        <?> "integer literal"


float : Parser s E
float =
    EFloat
        <$> Combine.Num.float
        <?> "float literal"


char : Parser s E
char =
    let
        charLiteral =
            string "#\\"
                *> choice
                    [ ' ' <$ string "space"
                    , '\n' <$ string "newline"
                    , anyChar
                    ]
    in
        EChar
            <$> charLiteral
            <?> "character literal"


str : Parser s E
str =
    EString
        <$> regex "\"(\\\"|[^\"])+\""
        <?> "string literal"


identifier : Parser s E
identifier =
    let
        letter =
            "a-zA-Z"

        specialInitial =
            "!$%&*/:<=>?^_~+\\-"

        initial =
            letter ++ specialInitial

        initialRe =
            "[" ++ initial ++ "]"

        digit =
            "0-9"

        specialSubsequent =
            ".@+\\-"

        subsequent =
            initial ++ digit ++ specialSubsequent

        subsequentRe =
            "[" ++ subsequent ++ "]*"

        identifierRe =
            initialRe ++ subsequentRe
    in
        EIdentifier <$> regex identifierRe <?> "identifier"


list : Parser s E
list =
    EList
        <$> parens (many expr)
        <?> "list"


vector : Parser s E
vector =
    EVector
        <$> (string "#(" *> many expr <* string ")")
        <?> "vector"


quote : Parser s E
quote =
    EQuote
        <$> (string "'" *> expr)
        <?> "quoted expression"


quasiquote : Parser s E
quasiquote =
    EQuasiquote
        <$> (string "`" *> expr)
        <?> "quasiquoted expression"


unquote : Parser s E
unquote =
    EUnquote
        <$> (string "," *> expr)
        <?> "unquoted expression"


unquoteSplice : Parser s E
unquoteSplice =
    EUnquoteSplice
        <$> (string ",@" *> expr)
        <?> "spliced expression"


expr : Parser s E
expr =
    lazy <|
        \() ->
            let
                parsers =
                    [ bool
                    , float
                    , int
                    , char
                    , str
                    , identifier
                    , list
                    , vector
                    , quote
                    , quasiquote
                    , unquote
                    , unquoteSplice
                    , comment
                    ]
            in
                whitespace *> choice parsers <* whitespace


program : Parser s (List E)
program =
    manyTill expr end


formatError : List String -> InputStream -> String
formatError ms stream =
    let
        location =
            currentLocation stream

        separator =
            "|> "

        expectationSeparator =
            "\n  * "

        lineNumberOffset =
            floor (logBase 10 (toFloat location.line)) + 1

        separatorOffset =
            String.length separator

        padding =
            location.column + separatorOffset + 2
    in
        "Parse error around line:\n\n"
            ++ toString location.line
            ++ separator
            ++ location.source
            ++ "\n"
            ++ String.padLeft padding ' ' "^"
            ++ "\nI expected one of the following:\n"
            ++ expectationSeparator
            ++ String.join expectationSeparator ms


parse : String -> Result String (List E)
parse s =
    case Combine.parse program s of
        Ok ( _, _, e ) ->
            Ok e

        Err ( _, stream, ms ) ->
            Err <| formatError ms stream
>>>>src/../elm-stuff/packages/elm-community/parser-combinators/1.1.0/src/Combine/Char.elm
module Combine.Char exposing (satisfy, char, anyChar, oneOf, noneOf, space, tab, newline, crlf, eol, lower, upper, digit, octDigit, hexDigit)

{-| This module contains `Char`-specific Parsers.

Avoid using this module if performance is a concern. You can achieve
everything that you can do with this module by using `Combine.regex`,
`Combine.string` or `Combine.primitive` and, in general, those will be
much faster.

# Parsers
@docs satisfy, char, anyChar, oneOf, noneOf, space, tab, newline, crlf, eol, lower, upper, digit, octDigit, hexDigit
-}

import Char
import Combine exposing (Parser, primitive, regex, (<?>), (<$), (<|>))
import String


{-| Parse a character matching the predicate.

    parse (satisfy ((==) 'a')) "a" ==
    -- Ok 'a'

    parse (satisfy ((==) 'a')) "b" ==
    -- Err ["could not satisfy predicate"]

-}
satisfy : (Char -> Bool) -> Parser s Char
satisfy pred =
    primitive <|
        \state stream ->
            let
                message =
                    "could not satisfy predicate"
            in
                case String.uncons stream.input of
                    Just ( h, rest ) ->
                        if pred h then
                            ( state, { stream | input = rest, position = stream.position + 1 }, Ok h )
                        else
                            ( state, stream, Err [ message ] )

                    Nothing ->
                        ( state, stream, Err [ message ] )


{-| Parse an exact character match.

    parse (char 'a') "a" ==
    -- Ok 'a'

    parse (char 'a') "b" ==
    -- Err ["expected 'a'"]

-}
char : Char -> Parser s Char
char c =
    satisfy ((==) c) <?> ("expected " ++ toString c)


{-| Parse any character.

    parse anyChar "a" ==
    -- Ok 'a'

    parse anyChar "" ==
    -- Err ["expected any character"]

-}
anyChar : Parser s Char
anyChar =
    satisfy (always True) <?> "expected any character"


{-| Parse a character from the given list.

    parse (oneOf ['a', 'b']) "a" ==
    -- Ok 'a'

    parse (oneOf ['a', 'b']) "c" ==
    -- Err ["expected one of ['a','b']"]

-}
oneOf : List Char -> Parser s Char
oneOf cs =
    satisfy (flip List.member cs) <?> ("expected one of " ++ toString cs)


{-| Parse a character that is not in the given list.

    parse (noneOf ['a', 'b']) "c" ==
    -- Ok 'c'

    parse (noneOf ['a', 'b']) "a" ==
    -- Err ["expected none of ['a','b']"]

-}
noneOf : List Char -> Parser s Char
noneOf cs =
    satisfy (not << flip List.member cs) <?> ("expected none of " ++ toString cs)


{-| Parse a space character.
-}
space : Parser s Char
space =
    satisfy ((==) ' ') <?> "expected space"


{-| Parse a `\t` character.
-}
tab : Parser s Char
tab =
    satisfy ((==) '\t') <?> "expected tab"


{-| Parse a `\n` character.
-}
newline : Parser s Char
newline =
    satisfy ((==) '\n') <?> "expected newline"


{-| Parse a `\r\n` sequence, returning a `\n` character.
-}
crlf : Parser s Char
crlf =
    '\n' <$ regex "\x0D\n" <?> "expected crlf"


{-| Parse an end of line character or sequence, returning a `\n` character.
-}
eol : Parser s Char
eol =
    newline <|> crlf


{-| Parse any lowercase character.
-}
lower : Parser s Char
lower =
    satisfy Char.isLower <?> "expected a lowercase character"


{-| Parse any uppercase character.
-}
upper : Parser s Char
upper =
    satisfy Char.isUpper <?> "expected an uppercase character"


{-| Parse any base 10 digit.
-}
digit : Parser s Char
digit =
    satisfy Char.isDigit <?> "expected a digit"


{-| Parse any base 8 digit.
-}
octDigit : Parser s Char
octDigit =
    satisfy Char.isOctDigit <?> "expected an octal digit"


{-| Parse any base 16 digit.
-}
hexDigit : Parser s Char
hexDigit =
    satisfy Char.isHexDigit <?> "expected a hexadecimal digit"
>>>>src/../elm-stuff/packages/elm-community/parser-combinators/1.1.0/src/Combine/Num.elm
module Combine.Num
    exposing
        ( sign
        , digit
        , int
        , float
        )

{-| This module contains Parsers specific to parsing numbers.

# Parsers
@docs sign, digit, int, float
-}

import Char
import Combine exposing (..)
import Combine.Char
import String


unwrap : (String -> Result x res) -> String -> res
unwrap f s =
    case f s of
        Ok res ->
            res

        Err m ->
            Debug.crash ("impossible state in Combine.Num.unwrap: " ++ toString m)


toInt : String -> Int
toInt =
    unwrap String.toInt


toFloat : String -> Float
toFloat =
    unwrap String.toFloat


{-| Parse a numeric sign, returning `1` for positive numbers and `-1`
for negative numbers.
-}
sign : Parser s Int
sign =
    optional 1
        (choice
            [ 1 <$ string "+"
            , -1 <$ string "-"
            ]
        )


{-| Parse a digit.
-}
digit : Parser s Int
digit =
    let
        toDigit c =
            Char.toCode c - Char.toCode '0'
    in
        toDigit <$> Combine.Char.digit <?> "expected a digit"


{-| Parse an integer.
-}
int : Parser s Int
int =
    (*)
        <$> sign
        <*> (toInt <$> regex "(0|[1-9][0-9]*)")
        <?> "expected an integer"


{-| Parse a float.
-}
float : Parser s Float
float =
    ((*) << Basics.toFloat)
        <$> sign
        <*> (toFloat <$> regex "(0|[1-9][0-9]*)(\\.[0-9]+)")
        <?> "expected a float"
>>>>src/../elm-stuff/packages/elm-community/parser-combinators/1.1.0/src/Combine.elm
module Combine
    exposing
        ( Parser
        , InputStream
        , ParseLocation
        , ParseContext
        , ParseResult
        , ParseErr
        , ParseOk
        , primitive
        , app
        , lazy
        , parse
        , runParser
        , withState
        , putState
        , modifyState
        , withLocation
        , withLine
        , withColumn
        , currentLocation
        , currentSourceLine
        , currentLine
        , currentColumn
        , map
        , mapError
        , andThen
        , andMap
        , sequence
        , fail
        , succeed
        , string
        , regex
        , end
        , whitespace
        , whitespace1
        , lookAhead
        , while
        , or
        , choice
        , optional
        , maybe
        , many
        , many1
        , manyTill
        , sepBy
        , sepBy1
        , sepEndBy
        , sepEndBy1
        , skip
        , skipMany
        , skipMany1
        , chainl
        , chainr
        , count
        , between
        , parens
        , braces
        , brackets
        , (<?>)
        , (>>=)
        , (<$>)
        , (<$)
        , ($>)
        , (<*>)
        , (<*)
        , (*>)
        , (<|>)
        )

{-| This library provides facilities for parsing structured text data
into concrete Elm values.

## API Reference

* [Core Types](#core-types)
* [Running Parsers](#running-parsers)
* [Constructing Parsers](#constructing-parsers)
* [Parsers](#parsers)
* [Combinators](#combinators)
  * [Transforming Parsers](#transforming-parsers)
  * [Chaining Parsers](#chaining-parsers)
  * [Parser Combinators](#parser-combinators)
  * [State Combinators](#state-combinators)

## Core Types
@docs Parser, InputStream, ParseLocation, ParseContext, ParseResult, ParseErr, ParseOk

## Running Parsers
@docs parse, runParser

## Constructing Parsers
@docs primitive, app, lazy

## Parsers
@docs fail, succeed, string, regex, end, whitespace, whitespace1

## Combinators

### Transforming Parsers
@docs map, (<$>), (<$), ($>), mapError, (<?>)

### Chaining Parsers
@docs andThen, (>>=), andMap, (<*>), (<*), (*>), sequence

### Parser Combinators
@docs lookAhead, while, or, (<|>), choice, optional, maybe, many, many1, manyTill, sepBy, sepBy1, sepEndBy, sepEndBy1, skip, skipMany, skipMany1, chainl, chainr, count, between, parens, braces, brackets

### State Combinators
@docs withState, putState, modifyState, withLocation, withLine, withColumn, currentLocation, currentSourceLine, currentLine, currentColumn
-}

import Lazy as L
import Regex exposing (Regex)
import String


{-| The input stream over which `Parser`s operate.

* `data` is the initial input provided by the user
* `input` is the remainder after running a parse
* `position` is the starting position of `input` in `data` after a parse

-}
type alias InputStream =
    { data : String
    , input : String
    , position : Int
    }


initStream : String -> InputStream
initStream s =
    InputStream s s 0


{-| A record representing the current parse location in an InputStream.

* `source` the current line of source code
* `line` the current line number (starting at 1)
* `column` the current column (starting at 1)
-}
type alias ParseLocation =
    { source : String
    , line : Int
    , column : Int
    }


{-| A tuple representing the current parser state, the remaining input
stream and the parse result.  Don't worry about this type unless
you're writing your own `primitive` parsers.
-}
type alias ParseContext state res =
    ( state, InputStream, ParseResult res )


{-| Running a `Parser` results in one of two states:

* `Ok res` when the parser has successfully parsed the input
* `Err messages` when the parser has failed with a list of error messages.
-}
type alias ParseResult res =
    Result (List String) res


{-| A tuple representing a failed parse.  It contains the state after
running the parser, the remaining input stream and a list of
error messages.
-}
type alias ParseErr state =
    ( state, InputStream, List String )


{-| A tuple representing a successful parse.  It contains the state
after running the parser, the remaining input stream and the
result.
-}
type alias ParseOk state res =
    ( state, InputStream, res )


type alias ParseFn state res =
    state -> InputStream -> ParseContext state res


{-| The Parser type.

At their core, `Parser`s wrap functions from some `state` and an
`InputStream` to a tuple representing the new `state`, the
remaining `InputStream` and a `ParseResult res`.
-}
type Parser state res
    = Parser (ParseFn state res)
    | RecursiveParser (L.Lazy (ParseFn state res))


{-| Construct a new primitive Parser.

If you find yourself reaching for this function often consider opening
a [Github issue][issues] with the library to have your custom Parsers
included in the standard distribution.

[issues]: https://github.com/elm-community/parser-combinators/issues
-}
primitive : (state -> InputStream -> ParseContext state res) -> Parser state res
primitive =
    Parser


{-| Unwrap a parser so it can be applied to a state and an input
stream.  This function is useful if you want to construct your own
parsers via `primitive`.  If you're using this outside of the context
of `primitive` then you might be doing something wrong so try asking
for help on the mailing list.

Here's how you would implement a greedy version of `manyTill` using
`primitive` and `app`:

    manyTill : Parser s a -> Parser s x -> Parser s (List a)
    manyTill p end =
      let
        accumulate acc state stream =
          case app end state stream of
            (rstate, rstream, Ok _) ->
              (rstate, rstream, Ok (List.reverse acc))

            _ ->
              case app p state stream of
                (rstate, rstream, Ok res) ->
                  accumulate (res :: acc) rstate rstream

                (estate, estream, Err ms) ->
                  (estate, estream, Err ms)
      in
        primitive <| accumulate []

-}
app : Parser state res -> state -> InputStream -> ParseContext state res
app p =
    case p of
        Parser inner ->
            inner

        RecursiveParser t ->
            L.force t


{-| Parse a string.  See `runParser` if your parser needs to manage
some internal state.

    import Combine.Num exposing (int)
    import String

    parseAnInteger : String -> Result String Int
    parseAnInteger input =
      case parse int input of
        Ok (_, stream, result) ->
          Ok result

        Err (_, stream, errors) ->
          Err (String.join " or " errors)

    parseAnInteger "123"
    -- Ok 123

    parseAnInteger "abc"
    -- Err "expected an integer"

-}
parse : Parser () res -> String -> Result (ParseErr ()) (ParseOk () res)
parse p =
    runParser p ()


{-| Parse a string while maintaining some internal state.

    import Combine.Num exposing (int)
    import String

    type alias Output =
      { count : Int
      , integers : List Int
      }

    statefulInt : Parse Int Int
    statefulInt =
      -- Parse an int, then increment the state and return the parsed
      -- int.  It's important that we try to parse the int _first_
      -- since modifying the state will always succeed.
      int <* modifyState ((+) 1)

    ints : Parse Int (List Int)
    ints =
      sepBy (string " ") statefulInt

    parseIntegers : String -> Result String Output
    parseIntegers input =
      case runParser ints 0 input of
        Ok (state, stream, ints) ->
          Ok { count = state, integers = ints }

        Err (state, stream, errors) ->
          Err (String.join " or " errors)

    parseIntegers ""
    -- Ok { count = 0, integers = [] }

    parseIntegers "1 2 3 45"
    -- Ok { count = 4, integers = [1, 2, 3, 45] }

    parseIntegers "1 a 2"
    -- Ok { count = 1, integers = [1] }

-}
runParser : Parser state res -> state -> String -> Result (ParseErr state) (ParseOk state res)
runParser p st s =
    case app p st (initStream s) of
        ( state, stream, Ok res ) ->
            Ok ( state, stream, res )

        ( state, stream, Err ms ) ->
            Err ( state, stream, ms )


{-| Defer running a parser until it's actually required.  Use this
function to avoid "bad-recursion" errors.

    type Expression
      = ETerm String
      | EList (List E)

    name : Parser s String
    name = whitespace *> regex "[a-zA-Z]+" <* whitespace

    term : Parser s Expression
    term = ETerm <$> name

    list : Parser s Expression
    list =
      let
        -- helper is itself a function so we avoid the case where the
        -- value `list` tries to apply itself in its definition.
        helper () =
          EList <$> between (string "(") (string ")") (many (term <|> list))
      in
        -- lazy defers calling helper until it's actually needed.
        lazy helper

    parse list ""
    -- Err ["expected \"(\""]

    parse list "()"
    -- Ok (EList [])

    parse list "(a (b c))"
    -- Ok (EList [ETerm "a", EList [ETerm "b", ETerm "c"]])

-}
lazy : (() -> Parser s a) -> Parser s a
lazy t =
    RecursiveParser (L.lazy (\() -> app (t ())))


{-| Transform both the result and error message of a parser.
-}
bimap :
    (a -> b)
    -> (List String -> List String)
    -> Parser s a
    -> Parser s b
bimap fok ferr p =
    Parser <|
        \state stream ->
            case app p state stream of
                ( rstate, rstream, Ok res ) ->
                    ( rstate, rstream, Ok (fok res) )

                ( estate, estream, Err ms ) ->
                    ( estate, estream, Err (ferr ms) )



-- State management
-- ----------------


{-| Get the parser's state and pipe it into a parser.
-}
withState : (s -> Parser s a) -> Parser s a
withState f =
    Parser <|
        \state stream ->
            app (f state) state stream


{-| Replace the parser's state.
-}
putState : s -> Parser s ()
putState state =
    Parser <|
        \_ stream ->
            app (succeed ()) state stream


{-| Modify the parser's state.
-}
modifyState : (s -> s) -> Parser s ()
modifyState f =
    Parser <|
        \state stream ->
            app (succeed ()) (f state) stream


{-| Get the current position in the input stream and pipe it into a parser.
-}
withLocation : (ParseLocation -> Parser s a) -> Parser s a
withLocation f =
    Parser <|
        \state stream ->
            app (f <| currentLocation stream) state stream


{-| Get the current line and pipe it into a parser.
-}
withLine : (Int -> Parser s a) -> Parser s a
withLine f =
    Parser <|
        \state stream ->
            app (f <| currentLine stream) state stream


{-| Get the current column and pipe it into a parser.
-}
withColumn : (Int -> Parser s a) -> Parser s a
withColumn f =
    Parser <|
        \state stream ->
            app (f <| currentColumn stream) state stream


{-| Get the current `(line, column)` in the input stream.
-}
currentLocation : InputStream -> ParseLocation
currentLocation stream =
    let
        find position currentLine lines =
            case lines of
                [] ->
                    ParseLocation "" 1 position

                [ line ] ->
                    ParseLocation line (currentLine + 1) position

                line :: rest ->
                    let
                        length =
                            String.length line
                    in
                        if position >= length then
                            find (position - length - 1) (currentLine + 1) rest
                        else if currentLine == 0 then
                            ParseLocation line 1 position
                        else
                            ParseLocation line currentLine (position - 1)
    in
        find stream.position 0 (String.split "\n" stream.data)


{-| Get the current source line in the input stream.
-}
currentSourceLine : InputStream -> String
currentSourceLine =
    currentLocation >> .source


{-| Get the current line in the input stream.
-}
currentLine : InputStream -> Int
currentLine =
    currentLocation >> .line


{-| Get the current column in the input stream.
-}
currentColumn : InputStream -> Int
currentColumn =
    currentLocation >> .column



-- Transformers
-- ------------


{-| Transform the result of a parser.

    let
      parser =
        string "a"
          |> map String.toUpper
    in
      parse parser "a"
      -- Ok "A"

-}
map : (a -> b) -> Parser s a -> Parser s b
map f p =
    bimap f identity p


{-| Transform the error of a parser.

    let
      parser =
        string "a"
          |> mapError (always ["bad input"])
    in
      parse parser b
      -- Err ["bad input"]

-}
mapError : (List String -> List String) -> Parser s a -> Parser s a
mapError =
    bimap identity


{-| Sequence two parsers, passing the result of the first parser to a
function that returns the second parser. The value of the second
parser is returned on success.

    import Combine.Num exposing (int)

    choosy : Parser s String
    choosy =
      let
        createParser n =
          if n % 2 == 0 then
            string " is even"
          else
            string " is odd"
      in
        int
          |> andThen createParser

    parse choosy "1 is odd"
    -- Ok " is odd"

    parse choosy "2 is even"
    -- Ok " is even"

    parse choosy "1 is even"
    -- Err ["expected \" is odd\""]

-}
andThen : (a -> Parser s b) -> Parser s a -> Parser s b
andThen f p =
    Parser <|
        \state stream ->
            case app p state stream of
                ( rstate, rstream, Ok res ) ->
                    app (f res) rstate rstream

                ( estate, estream, Err ms ) ->
                    ( estate, estream, Err ms )


{-| Sequence two parsers.

    import Combine.Num exposing (int)

    plus : Parser s String
    plus = string "+"

    sum : Parser s Int
    sum =
      int
        |> map (+)
        |> andMap (plus *> int)

    parse sum "1+2"
    -- Ok 3

-}
andMap : Parser s a -> Parser s (a -> b) -> Parser s b
andMap rp lp =
    lp >>= flip map rp


{-| Run a list of parsers in sequence, accumulating the results.  The
main use case for this parser is when you want to combine a list of
parsers into a single, top-level, parser.  For most use cases, you'll
want to use one of the other combinators instead.

    parse (sequence [string "a", string "b"]) "ab"
    -- Ok ["a", "b"]

    parse (sequence [string "a", string "b"]) "ac"
    -- Err ["expected \"b\""]

-}
sequence : List (Parser s a) -> Parser s (List a)
sequence parsers =
    let
        accumulate acc ps state stream =
            case ps of
                [] ->
                    ( state, stream, Ok (List.reverse acc) )

                x :: xs ->
                    case app x state stream of
                        ( rstate, rstream, Ok res ) ->
                            accumulate (res :: acc) xs rstate rstream

                        ( estate, estream, Err ms ) ->
                            ( estate, estream, Err ms )
    in
        Parser <|
            \state stream ->
                accumulate [] parsers state stream



-- Combinators
-- -----------


{-| Fail without consuming any input.

    parse (fail "some error") "hello"
    -- Err ["some error"]

-}
fail : String -> Parser s a
fail m =
    Parser <|
        \state stream ->
            ( state, stream, Err [ m ] )


emptyErr : Parser s a
emptyErr =
    Parser <|
        \state stream ->
            ( state, stream, Err [] )


{-| Return a value without consuming any input.

    parse (succeed 1) "a"
    -- Ok 1

-}
succeed : a -> Parser s a
succeed res =
    Parser <|
        \state stream ->
            ( state, stream, Ok res )


{-| Parse an exact string match.

    parse (string "hello") "hello world"
    -- Ok "hello"

    parse (string "hello") "goodbye"
    -- Err ["expected \"hello\""]

-}
string : String -> Parser s String
string s =
    Parser <|
        \state stream ->
            if String.startsWith s stream.input then
                let
                    len =
                        String.length s

                    rem =
                        String.dropLeft len stream.input

                    pos =
                        stream.position + len
                in
                    ( state, { stream | input = rem, position = pos }, Ok s )
            else
                ( state, stream, Err [ "expected " ++ toString s ] )


{-| Parse a Regex match.

Regular expressions must match from the beginning of the input and their
subgroups are ignored. A `^` is added implicitly to the beginning of
every pattern unless one already exists.

    parse (regex "a+") "aaaaab"
    -- Ok "aaaaa"

-}
regex : String -> Parser s String
regex pat =
    let
        pattern =
            if String.startsWith "^" pat then
                pat
            else
                "^" ++ pat
    in
        Parser <|
            \state stream ->
                case Regex.find (Regex.AtMost 1) (Regex.regex pattern) stream.input of
                    [ match ] ->
                        let
                            len =
                                String.length match.match

                            rem =
                                String.dropLeft len stream.input

                            pos =
                                stream.position + len
                        in
                            ( state, { stream | input = rem, position = pos }, Ok match.match )

                    _ ->
                        ( state, stream, Err [ "expected input matching Regexp /" ++ pattern ++ "/" ] )


{-| Consume input while the predicate matches.

    parse (while ((/=) ' ')) "test 123"
    -- Ok "test"

-}
while : (Char -> Bool) -> Parser s String
while pred =
    let
        accumulate acc state stream =
            case String.uncons stream.input of
                Just ( h, rest ) ->
                    if pred h then
                        let
                            c =
                                String.cons h ""

                            pos =
                                stream.position + 1
                        in
                            accumulate (acc ++ c) state { stream | input = rest, position = pos }
                    else
                        ( state, stream, acc )

                Nothing ->
                    ( state, stream, acc )
    in
        Parser <|
            \state stream ->
                let
                    ( rstate, rstream, res ) =
                        accumulate "" state stream
                in
                    ( rstate, rstream, Ok res )


{-| Fail when the input is not empty.

    parse end ""
    -- Ok ()

    parse end "a"
    -- Err ["expected end of input"]

-}
end : Parser s ()
end =
    Parser <|
        \state stream ->
            if stream.input == "" then
                ( state, stream, Ok () )
            else
                ( state, stream, Err [ "expected end of input" ] )


{-| Apply a parser without consuming any input on success.
-}
lookAhead : Parser s a -> Parser s a
lookAhead p =
    Parser <|
        \state stream ->
            case app p state stream of
                ( rstate, _, Ok res ) ->
                    ( rstate, stream, Ok res )

                err ->
                    err


{-| Choose between two parsers.

    parse (or (string "a") (string "b")) "a"
    -- Ok "a"

    parse (or (string "a") (string "b")) "b"
    -- Ok "b"

    parse (or (string "a") (string "b")) "c"
    -- Err ["expected \"a\"", "expected \"b\""]

-}
or : Parser s a -> Parser s a -> Parser s a
or lp rp =
    Parser <|
        \state stream ->
            case app lp state stream of
                ( _, _, Ok _ ) as res ->
                    res

                ( _, _, Err lms ) ->
                    case app rp state stream of
                        ( _, _, Ok _ ) as res ->
                            res

                        ( _, _, Err rms ) ->
                            ( state, stream, Err (lms ++ rms) )


{-| Choose between a list of parsers.

    parse (choice [string "a", string "b"]) "a"
    -- Ok "a"

    parse (choice [string "a", string "b"]) "b"
    -- Ok "b"

-}
choice : List (Parser s a) -> Parser s a
choice xs =
    List.foldr or emptyErr xs


{-| Return a default value when the given parser fails.

    letterA : Parser s String
    letterA = optional "a" (string "a")

    parse letterA "a"
    -- Ok "a"

    parse letterA "b"
    -- Ok "a"

-}
optional : a -> Parser s a -> Parser s a
optional res p =
    p <|> succeed res


{-| Wrap the return value into a `Maybe`.  Returns `Nothing` on failure.

    parse (maybe (string "a")) "a"
    -- Ok (Just "a")

    parse (maybe (string "a")) "b"
    -- Ok Nothing

-}
maybe : Parser s a -> Parser s (Maybe a)
maybe p =
    Parser <|
        \state stream ->
            case app p state stream of
                ( rstate, rstream, Ok res ) ->
                    ( rstate, rstream, Ok (Just res) )

                _ ->
                    ( state, stream, Ok Nothing )


{-| Apply a parser zero or more times and return a list of the results.

    parse (many (string "a")) "aaab"
    -- Ok ["a", "a", "a"]

    parse (many (string "a")) "bbbb"
    -- Ok []

    parse (many (string "a")) ""
    -- Ok []

-}
many : Parser s a -> Parser s (List a)
many p =
    let
        accumulate acc state stream =
            case app p state stream of
                ( rstate, rstream, Ok res ) ->
                    if stream == rstream then
                        ( rstate, rstream, List.reverse acc )
                    else
                        accumulate (res :: acc) rstate rstream

                _ ->
                    ( state, stream, List.reverse acc )
    in
        Parser <|
            \state stream ->
                let
                    ( rstate, rstream, res ) =
                        accumulate [] state stream
                in
                    ( rstate, rstream, Ok res )


{-| Parse at least one result.

    parse (many1 (string "a")) "a"
    -- Ok ["a"]

    parse (many1 (string "a")) ""
    -- Err ["expected \"a\""]

-}
many1 : Parser s a -> Parser s (List a)
many1 p =
    (::) <$> p <*> many p


{-| Apply the first parser zero or more times until second parser
succeeds. On success, the list of the first parser's results is returned.

    string "<!--" *> manyTill anyChar (string "-->")

-}
manyTill : Parser s a -> Parser s end -> Parser s (List a)
manyTill p end =
    let
        accumulate acc state stream =
            case app end state stream of
                ( rstate, rstream, Ok _ ) ->
                    ( rstate, rstream, Ok (List.reverse acc) )

                ( estate, estream, Err ms ) ->
                    case app p state stream of
                        ( rstate, rstream, Ok res ) ->
                            accumulate (res :: acc) rstate rstream

                        _ ->
                            ( estate, estream, Err ms )
    in
        Parser (accumulate [])


{-| Parser zero or more occurences of one parser separated by another.

    parse (sepBy (string ",") (string "a")) "b"
    -- Ok []

    parse (sepBy (string ",") (string "a")) "a,a,a"
    -- Ok ["a", "a", "a"]

    parse (sepBy (string ",") (string "a")) "a,a,b"
    -- Ok ["a", "a"]

-}
sepBy : Parser s x -> Parser s a -> Parser s (List a)
sepBy sep p =
    sepBy1 sep p <|> succeed []


{-| Parse one or more occurences of one parser separated by another.
-}
sepBy1 : Parser s x -> Parser s a -> Parser s (List a)
sepBy1 sep p =
    (::) <$> p <*> many (sep *> p)


{-| Parse zero or more occurences of one parser separated and
optionally ended by another.

    parse (sepEndBy (string ",") (string "a")) "a,a,a,"
    -- Ok ["a", "a", "a"]

-}
sepEndBy : Parser s x -> Parser s a -> Parser s (List a)
sepEndBy sep p =
    sepEndBy1 sep p <|> succeed []


{-| Parse one or more occurences of one parser separated and
optionally ended by another.

    parse (sepEndBy1 (string ",") (string "a")) ""
    -- Err ["expected \"a\""]

    parse (sepEndBy1 (string ",") (string "a")) "a"
    -- Ok ["a"]

    parse (sepEndBy1 (string ",") (string "a")) "a,"
    -- Ok ["a"]

-}
sepEndBy1 : Parser s x -> Parser s a -> Parser s (List a)
sepEndBy1 sep p =
    sepBy1 sep p <* maybe sep


{-| Apply a parser and skip its result.
-}
skip : Parser s x -> Parser s ()
skip p =
    () <$ p


{-| Apply a parser and skip its result many times.
-}
skipMany : Parser s x -> Parser s ()
skipMany p =
    () <$ many (skip p)


{-| Apply a parser and skip its result at least once.
-}
skipMany1 : Parser s x -> Parser s ()
skipMany1 p =
    () <$ many1 (skip p)


{-| Parse one or more occurences of `p` separated by `op`, recursively
apply all functions returned by `op` to the values returned by `p`. See
the `examples/Calc.elm` file for an example.
-}
chainl : Parser s (a -> a -> a) -> Parser s a -> Parser s a
chainl op p =
    let
        accumulate x =
            (op
                |> andThen
                    (\f ->
                        p
                            |> andThen (\y -> accumulate (f x y))
                    )
            )
                <|> succeed x
    in
        andThen accumulate p


{-| Similar to `chainl` but functions of `op` are applied in
right-associative order to the values of `p`.  See the
`examples/Python.elm` file for a usage example.
-}
chainr : Parser s (a -> a -> a) -> Parser s a -> Parser s a
chainr op p =
    let
        accumulate x =
            (op
                |> andThen
                    (\f ->
                        p
                            |> andThen accumulate
                            |> andThen (\y -> succeed (f x y))
                    )
            )
                <|> succeed x
    in
        andThen accumulate p


{-| Parse `n` occurences of `p`.
-}
count : Int -> Parser s a -> Parser s (List a)
count n p =
    let
        accumulate x acc =
            if x <= 0 then
                succeed (List.reverse acc)
            else
                andThen (\res -> accumulate (x - 1) (res :: acc)) p
    in
        accumulate n []


{-| Parse something between two other parsers.

The parser

    between (string "(") (string ")") (string "a")

is equivalent to the parser

    string "(" *> string "a" <* string ")"

-}
between : Parser s l -> Parser s r -> Parser s a -> Parser s a
between lp rp p =
    lp *> p <* rp


{-| Parse something between parentheses.
-}
parens : Parser s a -> Parser s a
parens =
    between (string "(") (string ")")


{-| Parse something between braces `{}`.
-}
braces : Parser s a -> Parser s a
braces =
    between (string "{") (string "}")


{-| Parse something between square brackets `[]`.
-}
brackets : Parser s a -> Parser s a
brackets =
    between (string "[") (string "]")


{-| Parse zero or more whitespace characters.

    parse (whitespace *> string "hello") "hello"
    -- Ok "hello"

    parse (whitespace *> string "hello") "   hello"
    -- Ok "hello"

-}
whitespace : Parser s String
whitespace =
    regex "[ \t\x0D\n]*" <?> "whitespace"


{-| Parse one or more whitespace characters.

    parse (whitespace1 *> string "hello") "hello"
     -- Err ["whitespace"]

    parse (whitespace1 *> string "hello") "   hello"
     -- Ok "hello"

-}
whitespace1 : Parser s String
whitespace1 =
    regex "[ \t\x0D\n]+" <?> "whitespace"



-- Infix operators
-- ---------------


{-| Variant of `mapError` that replaces the Parser's error with a List
of a single string.

    parse (string "a" <?> "gimme an 'a'") "b"
    -- Err ["gimme an 'a'"]

-}
(<?>) : Parser s a -> String -> Parser s a
(<?>) p m =
    mapError (always [ m ]) p


{-| Infix version of `andThen`.

    import Combine.Num exposing (int)

    choosy : Parser s String
    choosy =
      let
        createParser n =
          if n % 2 == 0 then
            string " is even"
          else
            string " is odd"
      in
        int >>= createParser

    parse choosy "1 is odd"
    -- Ok " is odd"

    parse choosy "2 is even"
    -- Ok " is even"

    parse choosy "1 is even"
    -- Err ["expected \" is odd\""]

-}
(>>=) : Parser s a -> (a -> Parser s b) -> Parser s b
(>>=) =
    flip andThen


{-| Infix version of `map`.

    parse (toString <$> int) "42"
    -- Ok "42"

    parse (toString <$> int) "abc"
    -- Err ["expected an integer"]

-}
(<$>) : (a -> b) -> Parser s a -> Parser s b
(<$>) =
    map


{-| Run a parser and return the value on the left on success.

    parse (True <$ string "true") "true"
    -- Ok True

    parse (True <$ string "true") "false"
    -- Err ["expected \"true\""]

-}
(<$) : a -> Parser s x -> Parser s a
(<$) res =
    map (always res)


{-| Run a parser and return the value on the right on success.

    parse (string "true" $> True) "true"
    -- Ok True

    parse (string "true" $> True) "false"
    -- Err ["expected \"true\""]

-}
($>) : Parser s x -> a -> Parser s a
($>) =
    flip (<$)


{-| Infix version of `andMap`.

    add : Int -> Int -> Int
    add = (+)

    plus : Parser s String
    plus = string "+"

    parse (add <$> int <*> (plus *> int)) "1+1"
    -- Ok 2

-}
(<*>) : Parser s (a -> b) -> Parser s a -> Parser s b
(<*>) =
    flip andMap


{-| Join two parsers, ignoring the result of the one on the right.

    unsuffix : Parser s String
    unsuffix =
      regex "[a-z]"
        <* regex "[!?]"

    parse unsuffix "a!"
    -- Ok "a"

-}
(<*) : Parser s a -> Parser s x -> Parser s a
(<*) lp rp =
    lp
        |> map always
        |> andMap rp


{-| Join two parsers, ignoring the result of the one on the left.

    unprefix : Parser s String
    unprefix =
      string ">"
        *> while ((==) ' ')
        *> while ((/=) ' ')

    parse unprefix "> a"
    -- Ok "a"

-}
(*>) : Parser s x -> Parser s a -> Parser s a
(*>) lp rp =
    lp
        |> map (flip always)
        |> andMap rp


{-| Synonym for `or`.
-}
(<|>) : Parser s a -> Parser s a -> Parser s a
(<|>) =
    or



-- Fixities


infixl 1 >>=


infixr 1 <|>


infixl 4 <$>


infixl 4 <$


infixl 4 $>


infixl 4 <*>


infixl 4 <*


infixl 4 *>
>>>>src/../elm-stuff/packages/evancz/elm-markdown/3.0.2/src/Markdown.elm
module Markdown exposing
  ( toHtml
  , Options, defaultOptions, toHtmlWith
  )

{-| A library for markdown parsing. This is just an Elm API built on top of the
[marked](https://github.com/chjj/marked) project which focuses on speed.

# Parsing Markdown
@docs toHtml

# Parsing with Custom Options
@docs Options, defaultOptions, toHtmlWith
-}

import Html exposing (Html, Attribute)
import Native.Markdown


{-| Turn a markdown string into an HTML element, using the `defaultOptions`.

    recipe : Html msg
    recipe =
       Markdown.toHtml [class "recipe"] """

    # Apple Pie Recipe

    First, invent the universe. Then bake an apple pie.

    """
-}
toHtml : List (Attribute msg) -> String -> Html msg
toHtml attrs string =
  Native.Markdown.toHtml defaultOptions attrs string


{-| Some parser options so you can tweak things for your particular case.

  * `githubFlavored` &mdash; overall reasonable improvements on the original
    markdown parser as described [here][gfm]. This includes stuff like [fenced
    code blocks][fenced]. There are some odd parts though, such as [tables][]
    and a setting to turn all newlines into newlines in the resulting output,
    so there are settings to turn those on or off based on your preference.

  * `defaultHighlighting` &mdash; a default language to use for code blocks that do
    not have a language tag. So setting this to `Just "elm"` will treat all
    unlabeled code blocks as Elm code. (This relies on [highlight.js][highlight]
    as explained in the README [here](../#code-blocks).)

  * `sanitize` &mdash; this determines if all HTML should be escaped. If you
    are parsing user markdown or user input can somehow reach the markdown
    parser, you should almost certainly turn on sanitation. If it is just you
    writing markdown, turning sanitation off is a nice way to do some HTML
    tricks if it is needed.

  * `smartypants` &mdash; This will automatically upgrade quotes to the
    prettier versions and turn dashes into [em dashes or en dashes][dash]


[gfm]: https://help.github.com/articles/github-flavored-markdown/
[fenced]: https://help.github.com/articles/github-flavored-markdown/#fenced-code-blocks
[tables]: https://help.github.com/articles/github-flavored-markdown/#tables
[highlight]: https://highlightjs.org/
[dash]: http://en.wikipedia.org/wiki/Dash
-}
type alias Options =
  { githubFlavored : Maybe { tables : Bool, breaks : Bool }
  , defaultHighlighting : Maybe String
  , sanitize : Bool
  , smartypants : Bool
  }


{-| The `Options` used by the `toElement` and `toHtml` functions.

    { githubFlavored = Just { tables = False, breaks = False }
    , defaultHighlighting = Nothing
    , sanitize = False
    , smartypants = False
    }
-}
defaultOptions : Options
defaultOptions =
  { githubFlavored = Just { tables = False, breaks = False }
  , defaultHighlighting = Nothing
  , sanitize = False
  , smartypants = False
  }


{-| Maybe you want to parse user input into markdown. To stop them from adding
`<script>` tags, you can use modified parsing options.

    options : Options
    options =
        { defaultOptions | sanitize = True }

    toMarkdown : String -> Html
    toMarkdown userInput =
        Markdown.toHtmlWith options [] userInput
-}
toHtmlWith : Options -> List (Attribute msg) -> String -> Html msg
toHtmlWith =
  Native.Markdown.toHtml
>>>>src/../elm-stuff/packages/rtfeldman/hex/1.0.0/src/Hex.elm
module Hex exposing (fromString, toString)

{-| Convert to and from Hex strings.

@docs fromString, toString
-}


{-| Convert a hexdecimal string such as "abc94f" to a decimal integer.

    Hex.fromString "a5" == Ok 165
    Hex.fromString "hat" == Err "invalid hexadecimal string"
-}
fromString : String -> Result String Int
fromString str =
    if String.isEmpty str then
        Err "Empty strings are not valid hexadecimal strings."
    else
        let
            result =
                if String.startsWith "-" str then
                    let
                        list =
                            str
                                |> String.toList
                                |> List.tail
                                |> Maybe.withDefault []
                    in
                        fromStringHelp (List.length list - 1) list 0
                            |> Result.map negate
                else
                    fromStringHelp (String.length str - 1) (String.toList str) 0

            formatError err =
                String.join " "
                    [ Basics.toString str
                    , "is not a valid hexadecimal string because"
                    , err
                    ]
        in
            Result.mapError formatError result


fromStringHelp : Int -> List Char -> Int -> Result String Int
fromStringHelp position chars accumulated =
    case chars of
        [] ->
            Ok accumulated

        char :: rest ->
            let
                recurse additional =
                    fromStringHelp
                        (position - 1)
                        rest
                        (accumulated + (additional * (16 ^ position)))
            in
                case char of
                    '0' ->
                        recurse 0

                    '1' ->
                        recurse 1

                    '2' ->
                        recurse 2

                    '3' ->
                        recurse 3

                    '4' ->
                        recurse 4

                    '5' ->
                        recurse 5

                    '6' ->
                        recurse 6

                    '7' ->
                        recurse 7

                    '8' ->
                        recurse 8

                    '9' ->
                        recurse 9

                    'a' ->
                        recurse 10

                    'b' ->
                        recurse 11

                    'c' ->
                        recurse 12

                    'd' ->
                        recurse 13

                    'e' ->
                        recurse 14

                    'f' ->
                        recurse 15

                    nonHex ->
                        Err (Basics.toString nonHex ++ " is not a valid hexadecimal character.")


{-| Convert a decimal integer to a hexdecimal string such as "abc94f"

    Hex.toString 165 == Ok "a5"
-}
toString : Int -> String
toString num =
    String.fromList <|
        if num < 0 then
            '-' :: unsafePositiveToDigits [] (negate num)
        else
            unsafePositiveToDigits [] num


{-| ONLY EVER CALL THIS WITH POSITIVE INTEGERS!
-}
unsafePositiveToDigits : List Char -> Int -> List Char
unsafePositiveToDigits digits num =
    if num < 16 then
        unsafeToDigit num :: digits
    else
        unsafePositiveToDigits (unsafeToDigit (num % 16) :: digits) (num // 16)


{-| ONLY EVER CALL THIS WITH INTEGERS BETWEEN 0 and 15!
-}
unsafeToDigit : Int -> Char
unsafeToDigit num =
    case num of
        0 ->
            '0'

        1 ->
            '1'

        2 ->
            '2'

        3 ->
            '3'

        4 ->
            '4'

        5 ->
            '5'

        6 ->
            '6'

        7 ->
            '7'

        8 ->
            '8'

        9 ->
            '9'

        10 ->
            'a'

        11 ->
            'b'

        12 ->
            'c'

        13 ->
            'd'

        14 ->
            'e'

        15 ->
            'f'

        _ ->
            Debug.crash ("Tried to convert " ++ toString num ++ " to hexadecimal.")
